const translations = {
  tm: {
    pageTitle: "BD katalogy — MedLibrary",
    brandEyebrow: "MedLibrary",
    brandTitle: "Bazada ýerleşýän katalog",
    brandLead: "dbMedicalLib.sqlite – kategoriýalar, kitaplar we çalt gözleg",
    navHome: "Baş sahypa",
    navCategories: "Kategoriýalar",
    navJson: "JSON katalogy",
    navDb: "BD katalogy",
    languageLabel: "Dil",
    heroTitle: "Integrirlenen kategoriýalar we kitaplar",
    heroSubtitle:
      "Maglumatlar gönüden-göni dbMedicalLib.sqlite bazasyndan alynýar: ady, awtory, kategoriýasy, dili we ýyly boýunça filtrleň.",
    statsBooks: "Kitaplar",
    statsCategories: "Kategoriýalar",
    panelTitle: "Gözleg",
    freeSearchLabel: "Erkin gözleg",
    freeSearchPlaceholder: "Ady, awtor, ISBN...",
    categoryLabel: "Kategoriýa",
    categoryAny: "Ähli kategoriýalar",
    languageLabelShort: "Dil",
    languageAny: "Islendik",
    statusLoading: "Katalog ýüklenýär...",
    catalogEmpty: "Katalog boş",
    statusFound: "{shown} / {total} kitap görkezilýär",
    filterNoResults: "Görnüşlere laýyk kitap tapylmady",
    untitled: "Ady ýok",
    metaAuthor: "Awtor",
    metaPublisher: "Neşirçi",
    metaCity: "Şäher",
    metaYear: "Ýyl",
    metaPages: "Sah.",
    metaPagesLabel: "Sahypa",
    metaLanguage: "Dil",
    metaIsbn: "ISBN",
    metaUdk: "UDK",
    metaBbk: "BBK",
    categoriesEmpty: "Kategoriýalar tapylmady",
    categoryCount: "{count} kitap",
    categoriesTitle: "Kategoriýalar",
    categoriesSubtitle: "Netijäni çalt gysgatmak üçin kategoriýa boýunça saýlaň.",
    categoriesLoading: "Ugry sanawyny ýükleýäris...",
    booksTitle: "Kitaplar",
    booksSubtitle: "Saýlanan süzgüçlere görä görkezilýär.",
    booksPlaceholder: "Bazadan maglumatlary garaşýarys...",
    loadError: "dbMedicalLib.sqlite bilen maglumat ýüklenmedi",
    optionAny: "Islendik",
    footerTitle: "© 2025 MedLibrary",
    footerText: "Lukmançylyk elektron kitaphanasy. Ähli hukuklar goralan.",
  },
  ru: {
    pageTitle: "Каталог БД — MedLibrary",
    brandEyebrow: "MedLibrary",
    brandTitle: "Каталог из базы данных",
    brandLead: "dbMedicalLib.sqlite — категории, книги и быстрый поиск",
    navHome: "Главная",
    navCategories: "Категории",
    navJson: "Каталог JSON",
    navDb: "Каталог БД",
    languageLabel: "Язык",
    heroTitle: "Интегрированные категории и книги",
    heroSubtitle:
      "Данные берутся напрямую из dbMedicalLib.sqlite. Фильтруйте по названию, авторам, категориям, языку и году.",
    statsBooks: "Книг",
    statsCategories: "Категорий",
    panelTitle: "Поиск",
    freeSearchLabel: "Свободный поиск",
    freeSearchPlaceholder: "Название, автор, ISBN...",
    categoryLabel: "Категория",
    categoryAny: "Все категории",
    languageLabelShort: "Язык",
    languageAny: "Любой",
    statusLoading: "Загружаем каталог...",
    catalogEmpty: "Каталог пуст",
    statusFound: "Найдено {shown} из {total} книг",
    filterNoResults: "Нет совпадений по заданным фильтрам.",
    untitled: "Без названия",
    metaAuthor: "Автор",
    metaPublisher: "Издатель",
    metaCity: "Город",
    metaYear: "Год",
    metaPages: "стр.",
    metaPagesLabel: "Страниц",
    metaLanguage: "Язык",
    metaIsbn: "ISBN",
    metaUdk: "УДК",
    metaBbk: "ББК",
    categoriesEmpty: "Категории не найдены",
    categoryCount: "{count} книг",
    categoriesTitle: "Категории",
    categoriesSubtitle: "Щёлкните по категории, чтобы сузить выдачу.",
    categoriesLoading: "Загружаем список направлений...",
    booksTitle: "Книги",
    booksSubtitle: "Показываем совпадения по выбранным фильтрам.",
    booksPlaceholder: "Ожидаем данные из базы...",
    loadError: "Не удалось загрузить dbMedicalLib.sqlite",
    optionAny: "Любой",
    footerTitle: "© 2025 MedLibrary",
    footerText: "Медицинская электронная библиотека. Все права защищены.",
  },
  en: {
    pageTitle: "DB catalogue — MedLibrary",
    brandEyebrow: "MedLibrary",
    brandTitle: "Database catalogue",
    brandLead: "dbMedicalLib.sqlite — categories, books, and fast filters",
    navHome: "Home",
    navCategories: "Categories",
    navJson: "JSON catalog",
    navDb: "DB catalog",
    languageLabel: "Language",
    heroTitle: "Integrated categories and books",
    heroSubtitle:
      "Data comes directly from dbMedicalLib.sqlite. Filter by title, author, category, language, and year.",
    statsBooks: "Books",
    statsCategories: "Categories",
    panelTitle: "Search",
    freeSearchLabel: "Free search",
    freeSearchPlaceholder: "Title, author, ISBN...",
    categoryLabel: "Category",
    categoryAny: "All categories",
    languageLabelShort: "Language",
    languageAny: "Any",
    statusLoading: "Loading catalog...",
    catalogEmpty: "Catalog is empty",
    statusFound: "Showing {shown} of {total} books",
    filterNoResults: "No matches for current filters.",
    untitled: "Untitled",
    metaAuthor: "Author",
    metaPublisher: "Publisher",
    metaCity: "City",
    metaYear: "Year",
    metaPages: "pages",
    metaPagesLabel: "Pages",
    metaLanguage: "Language",
    metaIsbn: "ISBN",
    metaUdk: "UDC",
    metaBbk: "BBK",
    categoriesEmpty: "No categories found",
    categoryCount: "{count} books",
    categoriesTitle: "Categories",
    categoriesSubtitle: "Click a category to narrow the list.",
    categoriesLoading: "Loading categories...",
    booksTitle: "Books",
    booksSubtitle: "Filtered results.",
    booksPlaceholder: "Waiting for data from the database...",
    loadError: "Failed to load dbMedicalLib.sqlite",
    optionAny: "Any",
    footerTitle: "© 2025 MedLibrary",
    footerText: "Medical digital library. All rights reserved.",
  },
};

let activeLang =
  document.documentElement.dataset.lang || document.documentElement.lang || "tm";

const state = {
  catalog: null,
  filteredBooks: [],
  activeCategory: "",
  activeLanguage: "",
  searchQuery: "",
};

const elements = {};
let apiBase = "";

const t = (key) =>
  translations[activeLang]?.[key] ??
  translations.tm?.[key] ??
  translations.ru?.[key] ??
  "";

const applyTranslations = () => {
  document.documentElement.lang = activeLang;
  document.documentElement.dataset.lang = activeLang;
  document.title = t("pageTitle") || document.title;

  document.querySelectorAll("[data-i18n]").forEach((node) => {
    const key = node.dataset.i18n;
    const value = t(key);
    if (value) {
      node.textContent = value;
    }
  });

  document.querySelectorAll("[data-i18n-placeholder]").forEach((node) => {
    const key = node.dataset.i18nPlaceholder;
    const value = t(key);
    if (value) {
      node.placeholder = value;
    }
  });

  if (state.catalog) {
    populateFilters();
    updateStatus();
    renderBooks();
  }
};

const normalizeValue = (value) =>
  value == null
    ? ""
    : value
        .toString()
        .trim()
        .toLowerCase()
        .replace(/\s+/g, " ");

const normalizeCategoryValue = (category) =>
  normalizeValue(category?.nameRu || category?.nameTm) || category?.id || "";

const resolveApiBase = () => {
  const url = new URL(window.location.href);
  const paramBase = url.searchParams.get("apiBase")?.trim();
  const bodyBase = document.body?.dataset.apiBase;
  const source = paramBase || bodyBase || "";
  return source.replace(/\/$/, "");
};

const formatPages = (pages) => {
  if (!pages) return "";
  return `${pages} ${t("metaPages")}`;
};

const updateStatus = () => {
  if (!elements.filterStatus || !state.catalog) return;
  const total = state.catalog.books.length;
  const shown = state.filteredBooks.length;
  if (total === 0) {
    elements.filterStatus.textContent = t("catalogEmpty");
    return;
  }
  elements.filterStatus.textContent =
    t("statusFound").replace("{shown}", shown).replace("{total}", total);
};

const renderBooks = () => {
  if (!elements.bookGrid) return;
  elements.bookGrid.innerHTML = "";

  if (!state.filteredBooks.length) {
    const placeholder = document.createElement("div");
    placeholder.className = "sqlite-placeholder";
    placeholder.textContent = t("filterNoResults");
    elements.bookGrid.appendChild(placeholder);
    return;
  }

  const fragment = document.createDocumentFragment();

  state.filteredBooks.forEach((book) => {
    const card = document.createElement("article");
    card.className = "sqlite-card";

    const title = document.createElement("h4");
    title.className = "sqlite-card__title";
    title.textContent = book.titleRu || book.titleTm || t("untitled");
    card.appendChild(title);

    if (book.titleTm && book.titleRu && book.titleTm !== book.titleRu) {
      const altTitle = document.createElement("p");
      altTitle.className = "sqlite-card__subtitle";
      altTitle.textContent = book.titleTm;
      card.appendChild(altTitle);
    }

    const metaList = document.createElement("dl");
    metaList.className = "sqlite-card__meta";

    const metaItems = [
      [t("metaAuthor"), book.authorRu || book.authorTm],
      [t("metaPublisher"), book.publisher],
      [t("metaCity"), book.city],
      [t("metaYear"), book.year],
      [t("metaPagesLabel"), formatPages(book.pages)],
      [t("metaLanguage"), book.language],
      [t("metaIsbn"), book.isbn],
      [t("metaUdk"), book.udk],
      [t("metaBbk"), book.bbk],
    ];

    metaItems.forEach(([label, value]) => {
      if (!value) return;
      const dt = document.createElement("dt");
      dt.textContent = label;
      const dd = document.createElement("dd");
      dd.textContent = value;
      metaList.append(dt, dd);
    });

    if (metaList.childNodes.length) {
      card.appendChild(metaList);
    }

    if (book.categories?.length) {
      const tagList = document.createElement("div");
      tagList.className = "sqlite-card__tags";
      book.categories.forEach((category) => {
        const tag = document.createElement("span");
        tag.className = "tag";
        tag.textContent = category.nameRu || category.nameTm;
        tagList.appendChild(tag);
      });
      card.appendChild(tagList);
    }

    fragment.appendChild(card);
  });

  elements.bookGrid.appendChild(fragment);
};

const setActiveCategory = (normalizedValue) => {
  state.activeCategory = normalizedValue;
  if (elements.categoryFilter) {
    elements.categoryFilter.value = normalizedValue;
  }
  renderCategoryCards();
  applyFilters();
};

const renderCategoryCards = () => {
  if (!elements.categoryList || !state.catalog) return;
  elements.categoryList.innerHTML = "";

  if (!state.catalog.categories.length) {
    const placeholder = document.createElement("p");
    placeholder.className = "muted";
    placeholder.textContent = t("categoriesEmpty");
    elements.categoryList.appendChild(placeholder);
    return;
  }

  const fragment = document.createDocumentFragment();

  state.catalog.categories.forEach((category) => {
    const button = document.createElement("button");
    button.type = "button";
    button.className = "category-chip";
    const normalized = normalizeCategoryValue(category);
    if (normalized && normalized === state.activeCategory) {
      button.classList.add("category-chip--active");
    }
    button.dataset.category = normalized;

    const title = document.createElement("span");
    title.className = "category-chip__title";
    title.textContent = category.nameRu || category.nameTm || t("untitled");

    const count = document.createElement("span");
    count.className = "category-chip__count";
    count.textContent = t("categoryCount").replace("{count}", category.count);

    button.append(title, count);
    button.addEventListener("click", () => {
      setActiveCategory(normalized === state.activeCategory ? "" : normalized);
    });

    fragment.appendChild(button);
  });

  elements.categoryList.appendChild(fragment);
};

const applyFilters = () => {
  if (!state.catalog) return;

  const query = normalizeValue(state.searchQuery);
  const category = state.activeCategory;
  const language = state.activeLanguage;

  state.filteredBooks = state.catalog.books.filter((book) => {
    const matchesQuery = !query
      ? true
      : [
          book.titleRu,
          book.titleTm,
          book.authorRu,
          book.authorTm,
          book.publisher,
          book.city,
          book.year,
          book.isbn,
          book.udk,
          book.bbk,
          ...(book.categories || []).map((categoryEntry) =>
            categoryEntry.nameRu || categoryEntry.nameTm
          ),
        ].some((value) => normalizeValue(value).includes(query));

    const matchesCategory = !category
      ? true
      : (book.categories || []).some(
          (entry) => normalizeCategoryValue(entry) === category
        );

    const matchesLanguage = !language
      ? true
      : normalizeValue(book.language) === language;

    return matchesQuery && matchesCategory && matchesLanguage;
  });

  updateStatus();
  renderBooks();
};

const populateFilters = () => {
  if (!state.catalog) return;

  if (elements.booksCount) {
    elements.booksCount.textContent = state.catalog.stats.books;
  }
  if (elements.categoriesCount) {
    elements.categoriesCount.textContent = state.catalog.stats.categories;
  }

  if (elements.categoryFilter) {
    const selected = elements.categoryFilter.value;
    elements.categoryFilter.innerHTML = "";
    const anyOption = document.createElement("option");
    anyOption.value = "";
    anyOption.textContent = t("categoryAny");
    elements.categoryFilter.appendChild(anyOption);
    state.catalog.categories.forEach((category) => {
      const option = document.createElement("option");
      const normalized = normalizeCategoryValue(category);
      option.value = normalized;
      option.textContent = category.nameRu || category.nameTm;
      elements.categoryFilter.appendChild(option);
    });
    elements.categoryFilter.value = selected;
  }

  if (elements.languageFilter) {
    const selected = elements.languageFilter.value;
    elements.languageFilter.innerHTML = "";
    const anyOption = document.createElement("option");
    anyOption.value = "";
    anyOption.textContent = t("languageAny");
    elements.languageFilter.appendChild(anyOption);
    const languages = Array.from(
      new Set(
        state.catalog.books
          .map((book) => book.language)
          .filter(Boolean)
          .map((lang) => normalizeValue(lang))
      )
    );

    languages
      .map((normalized) => {
        const display =
          state.catalog.books.find(
            (book) => normalizeValue(book.language) === normalized
          )?.language || normalized;
        return { normalized, display };
      })
      .forEach(({ normalized, display }) => {
        const option = document.createElement("option");
        option.value = normalized;
        option.textContent = display;
        elements.languageFilter.appendChild(option);
      });
    elements.languageFilter.value = selected;
  }

  renderCategoryCards();
};

const attachEvents = () => {
  elements.searchInput?.addEventListener("input", (event) => {
    state.searchQuery = event.target.value || "";
    applyFilters();
  });

  elements.categoryFilter?.addEventListener("change", (event) => {
    setActiveCategory(event.target.value || "");
  });

  elements.languageFilter?.addEventListener("change", (event) => {
    state.activeLanguage = event.target.value || "";
    applyFilters();
  });
};

const fetchCatalog = async () => {
  if (!elements.filterStatus) return;
  elements.filterStatus.textContent = t("statusLoading");

  try {
    const endpoint = apiBase ? `${apiBase}/db/catalog` : "/db/catalog";
    const response = await fetch(endpoint);
    if (!response.ok) {
      throw new Error("Ответ сервера: " + response.status);
    }
    const catalog = await response.json();
    state.catalog = catalog;
    state.filteredBooks = catalog.books;
    applyTranslations();
  } catch (error) {
    console.warn(error);
    elements.filterStatus.textContent = t("loadError");
    if (elements.bookGrid) {
      elements.bookGrid.innerHTML = "";
      const notice = document.createElement("div");
      notice.className = "sqlite-placeholder";
      notice.textContent = t("loadError");
      elements.bookGrid.appendChild(notice);
    }
    return;
  }
};

const init = () => {
  elements.searchInput = document.querySelector("[data-search-input]");
  elements.categoryFilter = document.querySelector("[data-category-filter]");
  elements.languageFilter = document.querySelector("[data-language-filter]");
  elements.filterStatus = document.querySelector("[data-filter-status]");
  elements.categoryList = document.querySelector("[data-category-list]");
  elements.bookGrid = document.querySelector("[data-book-grid]");
  elements.booksCount = document.querySelector("[data-books-count]");
  elements.categoriesCount = document.querySelector("[data-categories-count]");
  elements.languageSelect = document.getElementById("language-select");

  apiBase = resolveApiBase();
  if (document.body) {
    document.body.dataset.apiBase = apiBase;
  }

  if (elements.languageSelect) {
    if (elements.languageSelect.value !== activeLang) {
      elements.languageSelect.value = activeLang;
    }
    elements.languageSelect.addEventListener("change", (event) => {
      activeLang = event.target.value || "tm";
      applyTranslations();
    });
  }

  applyTranslations();
  attachEvents();
  fetchCatalog();
};

document.addEventListener("DOMContentLoaded", init);
