<!DOCTYPE html>
<html lang="tm" data-lang="tm">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#0d47a1">
  <title>Медицинская электронная библиотека — книги</title>
  <link rel="manifest" href="manifest.webmanifest">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles.css">
</head>

<body class="page" data-api-base="http://localhost:5000">
  <div class="page">
    <header class="site-header">
      <div class="container site-header__bar">
        <div class="site-header__brand">
          <p class="eyebrow" data-i18n="tagline">Медицинская электронная библиотека</p>
          <h1 class="site-header__title" data-i18n="heroTitle">Каталог медицинских книг</h1>
        </div>
        <div class="site-header__actions language-switcher">
          <label for="language-select" data-i18n="languageLabel">Язык интерфейса:</label>
          <select id="language-select" aria-label="Select interface language">
            <option value="tm" selected>Türkmençe</option>
            <option value="ru">Русский</option>
            <option value="en">English</option>
          </select>
        </div>
      </div>
      <nav class="site-nav" aria-label="Основная навигация">
        <div class="container site-nav__wrap">
          <a href="index.html" data-i18n="navHome">Главная</a>
          <a href="BookCategory.html" data-i18n="navCategories">Категории</a>
          <a href="book.html" aria-current="page" data-i18n="navBooks">Каталог книг</a>
          <a href="https://sites.google.com/view/lukmanylyksanlykitaphanasy/ba%C5%9F-sahypa" target="_blank" rel="noopener" data-i18n="navAltSite">Другой сайт библиотеки</a>
        </div>
      </nav>
    </header>
    <main class="container book-shell">
    <section class="filter-panel" aria-labelledby="filter-title">
      <div class="filter-panel__head">
        <p class="logo-area__eyebrow" data-i18n="filterEyebrow">Фильтр книг</p>
        <h2 id="filter-title" class="filter-panel__title" data-i18n="filterTitle">Найдите нужную литературу</h2>
        <p class="filter-panel__subtitle" data-i18n="filterSubtitle">Используйте отдельные поля ниже, чтобы быстро отфильтровать книги по названию, автору, году, разделу и языку.</p>
      </div>
      <div class="filter-form" id="filter-form">
        <label class="filter-field">
          <span data-i18n="labelTitle">Название книги</span>
          <input type="text" data-filter="title" data-i18n-placeholder="placeholderTitle" placeholder="Например: нейрохирургия" autocomplete="off">
        </label>
        <label class="filter-field">
          <span data-i18n="labelAuthor">Автор</span>
          <input type="text" data-filter="author" data-i18n-placeholder="placeholderAuthor" placeholder="Например: Apuzzo" autocomplete="off">
        </label>
        <label class="filter-field">
          <span data-i18n="labelYear">Год издания</span>
          <input type="text" inputmode="numeric" data-filter="year" data-i18n-placeholder="placeholderYear" placeholder="Например: 2018" autocomplete="off">
        </label>
        <label class="filter-field">
          <span data-i18n="labelSpecialty">Специальность / раздел</span>
          <input type="text" list="specialty-options" data-filter="specialty" data-i18n-placeholder="placeholderSpecialty" placeholder="Например: нейрохирургия" autocomplete="off">
          <datalist id="specialty-options"></datalist>
        </label>
        <label class="filter-field">
          <span data-i18n="labelLanguage">Язык</span>
          <input type="text" data-filter="language" data-i18n-placeholder="placeholderLanguage" placeholder="Например: EN" autocomplete="off">
        </label>
      </div>
      <div class="filter-actions">
        <button class="button button--primary" type="button" id="reset-filters" data-i18n="reset">Сбросить фильтры</button>
      </div>
    </section>
    <section class="status-bar">
      <span class="status-pill" id="status-pill">—</span>
    </section>
    <section id="book-grid" class="book-grid" aria-live="polite"></section>
  </main>
    <footer class="site-footer">
      <div class="container site-footer__content">
        <div>
          <strong data-i18n="contactTitle">Контакты</strong>
          <p><span data-i18n="contactPhone">Телефон:</span> <a href="tel:+99362234094">+993 62 23 40 94</a></p>
          <p><span data-i18n="contactEmail">Email:</span> <a href="mailto:tdlipf@gmail.com">tdlipf@gmail.com</a></p>
        </div>
        <div>
          <strong data-i18n="footerNavigation">Навигация</strong>
          <p><a href="index.html" data-i18n="navHome">Главная</a></p>
          <p><a href="BookCategory.html" data-i18n="navCategories">Категории</a></p>
        </div>
        <div>
          <strong data-i18n="footerRights">© 2025 Медицинская электронная библиотека</strong>
          <p data-i18n="footerText">Все права защищены. Проект создан для удобного доступа к медицинской литературе.</p>
        </div>
      </div>
    </footer>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.19.3/dist/xlsx.full.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script>
    const translations = {
      ru: {
        pageTitle: 'Медицинская электронная библиотека — книги',
        tagline: 'Медицинская электронная библиотека',
        heroTitle: 'Каталог медицинских книг',
        languageLabel: 'Язык интерфейса:',
        navHome: 'Главная',
        navCategories: 'Категории',
        navBooks: 'Каталог книг',
        navAltSite: 'Другой сайт библиотеки',
        filterEyebrow: 'Фильтр книг',
        filterTitle: 'Найдите нужную литературу',
        filterSubtitle: 'Используйте отдельные поля ниже, чтобы быстро отфильтровать книги по названию, автору, году, разделу и языку.',
        labelTitle: 'Название книги',
        labelAuthor: 'Автор',
        labelYear: 'Год издания',
        labelSpecialty: 'Специальность / раздел',
        labelLanguage: 'Язык',
        placeholderTitle: 'Например: нейрохирургия',
        placeholderAuthor: 'Например: Apuzzo',
        placeholderYear: 'Например: 2018',
        placeholderSpecialty: 'Например: радиология',
        placeholderLanguage: 'Например: EN',
        reset: 'Сбросить фильтры',
        statusLoading: 'Загружаем каталог...',
        statusEmpty: 'Ничего не найдено',
        statusTotal: 'Всего книг: {count}',
        statusFiltered: 'Найдено {count} из {total}',
        cardSpecialty: 'Раздел',
        cardYear: 'Год',
        cardLanguage: 'Язык',
        cardAuthor: 'Автор',
        cardCity: 'Город',
        cardPublisher: 'Издательство',
        cardPages: 'Страниц',
        cardOpen: 'Открыть файл',
        cardSearch: 'Найти книгу',
        cardCoverAlt: 'Обложка книги',
        cardSpecialtyEmpty: 'Не указано',
        cardLanguageEmpty: '—',
        contactTitle: 'Контакты',
        contactPhone: 'Телефон:',
        contactEmail: 'Email:',
        footerNavigation: 'Навигация',
        footerRights: '© 2025 Медицинская электронная библиотека',
        footerText: 'Все права защищены. Проект создан для удобного доступа к медицинской литературе.'
      },
      en: {
        pageTitle: 'Medical e-Library — books',
        tagline: 'Medical digital library',
        heroTitle: 'Medical book catalogue',
        languageLabel: 'Interface language:',
        navHome: 'Home',
        navCategories: 'Book categories',
        navBooks: 'Book list',
        navAltSite: 'Alternative library site',
        filterEyebrow: 'Book filters',
        filterTitle: 'Find the right resource',
        filterSubtitle: 'Use the dedicated fields below to filter books by title, author, year, specialty and language in real time.',
        labelTitle: 'Book title',
        labelAuthor: 'Author',
        labelYear: 'Year',
        labelSpecialty: 'Specialty / section',
        labelLanguage: 'Language',
        placeholderTitle: 'e.g. neurosurgery',
        placeholderAuthor: 'e.g. Apuzzo',
        placeholderYear: 'e.g. 2018',
        placeholderSpecialty: 'e.g. radiology',
        placeholderLanguage: 'e.g. EN',
        reset: 'Reset filters',
        statusLoading: 'Loading catalogue...',
        statusEmpty: 'No books match your filters',
        statusTotal: 'Total books: {count}',
        statusFiltered: 'Showing {count} of {total}',
        cardSpecialty: 'Specialty',
        cardYear: 'Year',
        cardLanguage: 'Language',
        cardAuthor: 'Author',
        cardCity: 'City',
        cardPublisher: 'Publisher',
        cardPages: 'Pages',
        cardOpen: 'Open file',
        cardSearch: 'Search online',
        cardCoverAlt: 'Book cover',
        cardSpecialtyEmpty: 'Not specified',
        cardLanguageEmpty: '—',
        contactTitle: 'Contacts',
        contactPhone: 'Phone:',
        contactEmail: 'Email:',
        footerNavigation: 'Navigation',
        footerRights: '© 2025 Medical e-Library',
        footerText: 'All rights reserved. The project was created to provide convenient access to medical literature.'
      },
      tm: {
        pageTitle: 'Lukmançylyk elektron kitaphanasy — kitaplar',
        tagline: 'Lukmançylyk elektron kitaphanasy',
        heroTitle: 'Lukmançylyk kitaplarynyň katalogy',
        languageLabel: 'Interfeýsiň dili:',
        navHome: 'Baş sahypa',
        navCategories: 'Kategoriýalar',
        navBooks: 'Kitap katalogy',
        navAltSite: 'Kitaphananyň beýleki sahypasy',
        filterEyebrow: 'Kitap süzgüçleri',
        filterTitle: 'Gerek kitaby tapyň',
        filterSubtitle: 'Aşakdaky meýdançalar arkaly kitabyny ady, awtory, ýyly, ugry we dili boýunça dessine saýlap bilersiňiz.',
        labelTitle: 'Kitabyň ady',
        labelAuthor: 'Awtor',
        labelYear: 'Çykan ýyly',
        labelSpecialty: 'Ugry / bölüm',
        labelLanguage: 'Dil',
        placeholderTitle: 'Mysal üçin: neýrohirurgiýa',
        placeholderAuthor: 'Mysal üçin: Apuzzo',
        placeholderYear: 'Mysal üçin: 2018',
        placeholderSpecialty: 'Mysal üçin: radiologiýa',
        placeholderLanguage: 'Mysal üçin: TM',
        reset: 'Süzgüçleri arassala',
        statusLoading: 'Katalog ýüklenýär...',
        statusEmpty: 'Talaplara laýyk kitap tapylmady',
        statusTotal: 'Jemi kitap: {count}',
        statusFiltered: '{total} kitabyň {count}-si görkezildi',
        cardSpecialty: 'Ugry',
        cardYear: 'Ýyl',
        cardLanguage: 'Dil',
        cardAuthor: 'Awtor',
        cardCity: 'Şäher',
        cardPublisher: 'Neşirýat',
        cardPages: 'Sahypa',
        cardOpen: 'Faýly aç',
        cardSearch: 'Internetden tap',
        cardCoverAlt: 'Kitabyň suraty',
        cardSpecialtyEmpty: 'Görkezilmedik',
        cardLanguageEmpty: '—',
        contactTitle: 'Habarlaşmak üçin',
        contactPhone: 'Telefon:',
        contactEmail: 'Email:',
        footerNavigation: 'Ugrukdyrmak',
        footerRights: '© 2025 Lukmançylyk elektron kitaphanasy',
        footerText: 'Ähli hukuklar goralan. Taslama lukmançylyk edebiýatyna amatly elýeterlik üçin döredildi.'
      }
    };

    const columnAliases = {
      title: ['Название книги', 'Book Name', 'Book Title', 'Kitaplar', 'Kitabyň ady', 'Name', 'title'],
      author: ['Имя автора', 'Authors Name', 'Author', 'Awtoryň ady', 'author'],
      publisher: ['Издатель', 'Publisher', 'Neşirçi', 'publisher'],
      city: ['Город публикации', 'Publication City', 'City', 'Şäher', 'city'],
      year: ['Год публикации', 'Publication Year', 'Год', 'Year', 'Ýyl', 'year'],
      pages: ['Количество страниц', 'Page Count', 'Pages', 'Sahypalar', 'pages'],
      language: ['Язык книги', 'Book Language', 'Dil', 'Language', 'language'],
      specialty: ['Специальность', 'Специальность / раздел', 'Раздел', 'Категория', 'Category', 'Specialty', 'Bölüm', 'Ugry', 'specialty'],
      link: ['Ссылка', 'Link', 'URL', 'Download', 'Файл', 'File', 'link'],
      cover: ['Обложка', 'Изображение', 'Фото', 'Cover', 'Image', 'Book image', 'H', '__COL_H', 'cover']
    };

    const API_BASE = resolveApiBase(document.body?.dataset.apiBase);
    const API_SOURCE = API_BASE ? `${API_BASE}/books` : '';
    const JSON_SOURCE = 'data/books_with_specialties.json';

    const BOOK_CACHE_KEY = 'medlibrary.bookCache';
    const BOOK_CACHE_VERSION = '4.0.0';
    const BOOK_CACHE_TTL = 1000 * 60 * 60 * 12; // 12 hours
    const excelSources = ['Book.xlsx'];
    const fallbackCoverImages = ['1.webp', '2.webp', '3.webp', '4.webp', '5.webp', '6.webp', '1.png', '2.png', '3.png', '4.png', '5.png', '6.png'];
    const fallbackCoverCache = new Map();
    const accentPattern = /[\u0300-\u036f]/g;
    const CATEGORY_TRANSLATIONS = [
      { ru: 'Акушерство и Гинекология', tm: 'Akuşerçilik we Ginekologiýa' },
      { ru: 'Анатомия', tm: 'Anatomiýa' },
      { ru: 'Ангиография', tm: 'Angiografiýa' },
      { ru: 'Английский язык', tm: 'Iňlis dili' },
      { ru: 'Анестезиология', tm: 'Anesteziologiýa' },
      { ru: 'Биохимия', tm: 'Biohimiýa' },
      { ru: 'Внутренние болезни', tm: 'Iç keseller' },
      { ru: 'Военно-полевая терапия', tm: 'Harby-meýdan terapiýasy' },
      { ru: 'Военно-полевая хирургия', tm: 'Harby-meýdan hirurgiýasy' },
      { ru: 'Гастроэнтерология', tm: 'Gastroenterologiýa' },
      { ru: 'Гематология', tm: 'Gematologiýa' },
      { ru: 'Гигиена', tm: 'Gigiýena' },
      { ru: 'Гистология, цитология', tm: 'Gistologiýa, sitologiýa' },
      { ru: 'Детская хирургия', tm: 'Çaga hirurgiýasy' },
      { ru: 'Диетология', tm: 'Dietologiýa' },
      { ru: 'Инфекционные болезни', tm: 'Ýokanç keseller' },
      { ru: 'Инфекционные болезни детей', tm: 'Çaga ýokanç keselleri' },
      { ru: 'История медицины', tm: 'Lukmançylyk taryhy' },
      { ru: 'Кардиология', tm: 'Kardiologiýa' },
      { ru: 'Кардиохирургия', tm: 'Kardiohirurgiýa' },
      { ru: 'Клиническая лабораторная диагностика.', tm: 'Клиническая лабораторная диагностика.' },
      { ru: 'Клиническая лаборатория', tm: 'Kliniki laboratoriýa' },
      { ru: 'Кожные и венерические болезни', tm: 'Deri we weneriki keseller' },
      { ru: 'Компьютерная томография', tm: 'Kompýuter tomografiýasy' },
      { ru: 'Компютерная томография-КТ', tm: 'Компютерная томография-КТ' },
      { ru: 'Латинский язык и медицинская терминология', tm: 'Latin dili we lukmançylyk terminologiýasy' },
      { ru: 'Латинский язык и основы медицинской терминологии.', tm: 'Латинский язык и основы медицинской терминологии.' },
      { ru: 'Лечебная физкультура', tm: 'Bejeriş beden terbiyesi' },
      { ru: 'Лечебная физическая культура', tm: 'Лечебная физическая культура' },
      { ru: 'Магнитно-резонансная томография', tm: 'Magnit rezonans tomografiýasy' },
      { ru: 'Магнитно-резонансная томография-МРТ', tm: 'Магнитно-резонансная томография-МРТ' },
      { ru: 'Медицинская биология', tm: 'Lukmançylyk biologiýasy' },
      { ru: 'Медицинская генетика', tm: 'Lukmançylyk genetikasy' },
      { ru: 'Медицинская и биологическая физика', tm: 'Lukmançylyk we biologik fizika' },
      { ru: 'Медицинская иммунология', tm: 'Lukmançylyk immunologiýasy' },
      { ru: 'Микробиология', tm: 'Mikrobiologiýa' },
      { ru: 'Наркология', tm: 'Narkologiýa' },
      { ru: 'Неврология', tm: 'Newrologiýa' },
      { ru: 'Нейрохирургия', tm: 'Neýrohirurgiýa' },
      { ru: 'Неонатология', tm: 'Neonatologiýa' },
      { ru: 'Общая и медицинская химия', tm: 'Umumy we lukmançylyk himiýasy' },
      { ru: 'Общая и медисинская экология.', tm: 'Общая и медисинская экология.' },
      { ru: 'Общая и неорганическая химия', tm: 'Umumy we organiki däl himiýa' },
      { ru: 'Общая и неорганическая химия.', tm: 'Общая и неорганическая химия.' },
      { ru: 'Онкология', tm: 'Onkologiýa' },
      { ru: 'Ортопедия', tm: 'Ортопедия' },
      { ru: 'Ортопедия и травматология', tm: 'Ortopediýa we trawmatologiýa' },
      { ru: 'Отоларингология', tm: 'Otolaringologiýa' },
      { ru: 'Оториноларингология-ЛОР', tm: 'Оториноларингология-ЛОР' },
      { ru: 'Офтальмология', tm: 'Oftalmologiýa' },
      { ru: 'Офтальмоло́гия', tm: 'Oftalmologiýa' },
      { ru: 'Патологическая анатомия', tm: 'Patologik anatomiýa' },
      { ru: 'Патологическая физиология', tm: 'Патологическая физиология' },
      { ru: 'Педиатрия', tm: 'Pediatriýa' },
      { ru: 'Пластическая хирургия', tm: 'Plastiki hirurgiýa' },
      { ru: 'Пропедевтика внутренних болезней', tm: 'Пропедевтика внутренних болезней' },
      { ru: 'Пропедевтика детских болезней', tm: 'Пропедевтика детских болезней' },
      { ru: 'Психиатрия', tm: 'Psihiatriýa' },
      { ru: 'Психология', tm: 'Psihologiýa' },
      { ru: 'Психология и психиатрия', tm: 'Психология и психиатрия' },
      { ru: 'Пульмонология', tm: 'Pulmonologiýa' },
      { ru: 'Радиология', tm: 'Radiologiýa' },
      { ru: 'Реанимация и интенсивная терапия', tm: 'Реанимация и интенсивная терапия' },
      { ru: 'Ревматология', tm: 'Ревматология' },
      { ru: 'Рентгенология и радиология', tm: 'Рентгенология и радиология' },
      { ru: 'Сердечно-сосудистая хирургия', tm: 'Ýürek-damar hirurgiýasy' },
      { ru: 'Сестринское дело', tm: 'Şepagat uýasy işi' },
      { ru: 'Социальная гигиена и организация здравоохранения', tm: 'Социальная гигиена и организация здравоохранения' },
      { ru: 'Спортивная медицина', tm: 'Спортивная медицина' },
      { ru: 'Стоматология', tm: 'Stomatologiýa' },
      { ru: 'Судебная медицина', tm: 'Kazyýet lukmançylygy' },
      { ru: 'Судебно-медицинская экспертиза', tm: 'Судебно-медицинская экспертиза' },
      { ru: 'Терапия', tm: 'Terapia' },
      { ru: 'Топографическая анатомия и оперативная хирургия', tm: 'Топографическая анатомия и оперативная хирургия' },
      { ru: 'Травматология', tm: 'Trawmatologiýa' },
      { ru: 'Ультразвуковая диагностика', tm: 'Ultrases barlagy' },
      { ru: 'Урология', tm: 'Урология' },
      { ru: 'Фармакология', tm: 'Farmakologiýa' },
      { ru: 'Физиология', tm: 'Fiziologiýa' },
      { ru: 'Физиотерапия', tm: 'Физиотерапия' },
      { ru: 'Фтизиатрия', tm: 'Ftiziatriýa' },
      { ru: 'Хирургия', tm: 'Hirurgiýa' },
      { ru: 'Электрокардиография', tm: 'Elektrokardiografiýa' },
      { ru: 'Электрокардиография-ЭКГ', tm: 'Электрокардиография-ЭКГ' },
      { ru: 'Эндокринология', tm: 'Endokrinologiýa' },
      { ru: 'Эпидемиология', tm: 'Epidemiologiýa' }
    ];
    const categoryTranslationMap = new Map(
      CATEGORY_TRANSLATIONS.map((entry) => [normalizeText(entry.ru), entry.tm])
    );
    const REMOTE_COVER_CACHE_KEY = 'medlibrary.remoteCovers';
    const REMOTE_COVER_CACHE_VERSION = '1';
    const remoteCoverCache = new Map();
    const coverFetchPromises = new Map();
    const idleCallback = window.requestIdleCallback || ((cb) => window.setTimeout(cb, 280));
    let remoteCoverCacheLoaded = false;
    let coverObserver = null;
    if (typeof IntersectionObserver !== 'undefined') {
      coverObserver = new IntersectionObserver((entries, observer) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            observer.unobserve(entry.target);
            upgradeCoverImage(entry.target);
          }
        });
      }, { rootMargin: '200px' });
    }
    let excelImageMap = new Map();
    const EXCEL_REL_NS = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships';
    const DRAWING_REL_TYPE = `${EXCEL_REL_NS}/drawing`;
    const XDR_NS = 'http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing';
    const DRAWING_NS = 'http://schemas.openxmlformats.org/drawingml/2006/main';

    const state = {
      lang: document.documentElement.lang || 'ru',
      books: [],
      cacheChecksum: '',
      filters: {
        title: '',
        author: '',
        year: '',
        specialty: '',
        language: ''
      }
    };

    function normalizeText(value) {
      if (typeof value !== 'string') {
        value = value == null ? '' : String(value);
      }
      return value.trim().toLowerCase().normalize('NFD').replace(accentPattern, '');
    }

    function translateSpecialty(value) {
      if (!value) return '';
      return categoryTranslationMap.get(normalizeText(value)) || value;
    }

    function collectSpecialtyOptions(books) {
      const seen = new Set();
      const options = [];
      books.forEach(({ specialty }) => {
        const original = (specialty || '').trim();
        const translated = translateSpecialty(original).trim();
        const originalKey = normalizeText(original);
        const translatedKey = normalizeText(translated);
        if (originalKey && !seen.has(originalKey)) {
          seen.add(originalKey);
          options.push(original);
        }
        if (translated && translatedKey && !seen.has(translatedKey)) {
          seen.add(translatedKey);
          options.push(translated);
        }
      });
      return options.sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));
    }

    function updateSpecialtyOptions(books = state.books) {
      const datalist = document.getElementById('specialty-options');
      if (!datalist) return;
      const options = collectSpecialtyOptions(Array.isArray(books) ? books : []);
      datalist.innerHTML = '';
      const fragment = document.createDocumentFragment();
      options.forEach((value) => {
        const option = document.createElement('option');
        option.value = value;
        fragment.appendChild(option);
      });
      datalist.appendChild(fragment);
    }

    function resolveApiBase(attributeBase = '') {
      const params = new URLSearchParams(window.location.search);
      const overrideBase = params.get('apiBase');
      let base = (overrideBase || attributeBase || '').trim();

      if (!base) {
        base = window.location.origin;
      }

      return base.replace(/\/$/, '');
    }

    document.addEventListener('DOMContentLoaded', () => {
      if (document.body) {
        document.body.dataset.apiBase = API_BASE;
      }
      initLanguageSwitcher();
      initFilters();
      loadBooks();
    });

    function initLanguageSwitcher() {
      const select = document.getElementById('language-select');
      if (!select) return;
      select.value = state.lang;
      select.addEventListener('change', () => {
        state.lang = select.value;
        document.documentElement.lang = state.lang;
        document.documentElement.dataset.lang = state.lang;
        applyTranslations();
        renderBooks();
      });
      applyTranslations();
    }

    function applyTranslations() {
      const dict = translations[state.lang] || translations.ru;
      document.title = dict.pageTitle;
      document.querySelectorAll('[data-i18n]').forEach((node) => {
        const key = node.dataset.i18n;
        if (dict[key]) {
          node.textContent = dict[key];
        }
      });
      document.querySelectorAll('[data-i18n-placeholder]').forEach((input) => {
        const key = input.dataset.i18nPlaceholder;
        if (dict[key]) {
          input.placeholder = dict[key];
        }
      });
    }

    function initFilters() {
      const form = document.getElementById('filter-form');
      form?.querySelectorAll('input[data-filter]').forEach((input) => {
        input.addEventListener('input', (event) => {
          const target = event.currentTarget;
          const name = target.dataset.filter;
          state.filters[name] = normalizeText(target.value);
          renderBooks();
        });
      });
      document.getElementById('reset-filters')?.addEventListener('click', () => {
        Object.keys(state.filters).forEach((key) => (state.filters[key] = ''));
        form?.querySelectorAll('input[data-filter]').forEach((input) => {
          input.value = '';
        });
        renderBooks();
      });
    }

    async function loadBooks() {
      updateStatus('statusLoading');
      const cached = readBooksFromCache();
      if (cached) {
        state.books = cached.books;
        state.cacheChecksum = cached.checksum || '';
        renderBooks();
        updateSpecialtyOptions(state.books);
      }
      const loaders = [
        API_SOURCE ? loadFromApiSource : null,
        loadFromJsonSource,
        loadFromExcelSource,
        loadFromTsvSource
      ].filter(Boolean);
      for (const loader of loaders) {
        try {
          const result = await loader();
          if (result && Array.isArray(result.books) && result.books.length) {
            state.books = result.books;
            renderBooks();
            updateSpecialtyOptions(state.books);
            persistBooks(state.books, result.cachePayload).catch(() => {});
            return;
          }
        } catch (error) {
          console.warn('Failed to load catalog from source', error);
        }
      }
      if (!state.books.length) {
        updateStatus('statusEmpty');
        const grid = document.getElementById('book-grid');
        if (grid) {
          grid.innerHTML = `<div class="empty-state">${translations[state.lang].statusEmpty}</div>`;
        }
      }
    }

    async function loadFromApiSource() {
      if (!API_SOURCE) {
        throw new Error('Catalog API is not configured');
      }
      const response = await fetch(API_SOURCE, { cache: 'no-store' });
      if (!response.ok) {
        throw new Error(`Network error while requesting ${API_SOURCE}`);
      }
      const payload = await response.json();
      const rows = Array.isArray(payload?.books) ? payload.books : payload;
      if (!Array.isArray(rows) || rows.length === 0) {
        throw new Error('Catalog API returned no data');
      }
      const books = rows
        .map((row) => normalizeRow(row))
        .filter((book) => book.title || book.author);
      return { books, cachePayload: JSON.stringify(rows) };
    }

    async function loadFromJsonSource() {
      if (!JSON_SOURCE) {
        throw new Error('Catalog source is not configured');
      }
      const response = await fetch(JSON_SOURCE, { cache: 'no-store' });
      if (!response.ok) {
        throw new Error(`Network error while requesting ${JSON_SOURCE}`);
      }
      const payload = await response.text();
      let rows;
      try {
        rows = JSON.parse(payload);
      } catch (error) {
        throw new Error('Failed to parse catalog JSON');
      }
      if (!Array.isArray(rows) || !rows.length) {
        throw new Error('Catalog JSON is empty');
      }
      const books = rows
        .map((row) => normalizeRow(row))
        .filter((book) => book.title || book.author);
      return { books, cachePayload: payload };
    }

    async function loadFromExcelSource() {
      if (typeof XLSX === 'undefined') {
        throw new Error('XLSX library is not available');
      }
      let lastError = null;
      for (const source of excelSources) {
        try {
          const response = await fetch(source, { cache: 'no-store' });
          if (!response.ok) {
            throw new Error(`Network error while requesting ${source}`);
          }
          const buffer = await response.arrayBuffer();
          const workbook = XLSX.read(buffer, { type: 'array' });
          const sheet = workbook.Sheets[workbook.SheetNames[0]];
          const rawRows = XLSX.utils.sheet_to_json(sheet, { header: 1, defval: '', blankrows: true });
          excelImageMap = await extractExcelImages(buffer).catch(() => new Map());
          const rows = convertSheetRowsToObjects(rawRows);
          const books = rows
            .map((row) => normalizeRow(row))
            .filter((book) => book.title || book.author);
          return { books, cachePayload: buffer };
        } catch (error) {
          lastError = error;
          console.warn(`Failed to load ${source}`, error);
        }
      }
      throw lastError || new Error('Excel sources are not available');
    }

    async function loadFromTsvSource() {
      const response = await fetch('books.html', { cache: 'no-store' });
      if (!response.ok) {
        throw new Error('Network error while requesting books.html');
      }
      const text = await response.text();
      const rows = parseTsv(text);
      const books = rows
        .map((row) => normalizeRow(row))
        .filter((book) => book.title || book.author);
      return { books, cachePayload: text };
    }

    function readBooksFromCache() {
      let storage;
      try {
        storage = window.localStorage;
      } catch (error) {
        console.warn('Local storage is not available', error);
        return null;
      }
      if (!storage) {
        return null;
      }
      try {
        const raw = storage.getItem(BOOK_CACHE_KEY);
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        if (parsed.version !== BOOK_CACHE_VERSION) return null;
        if (!Array.isArray(parsed.books) || !parsed.books.length) return null;
        if (typeof parsed.timestamp !== 'number' || Date.now() - parsed.timestamp > BOOK_CACHE_TTL) {
          return null;
        }
        return parsed;
      } catch (error) {
        console.warn('Failed to read cached books', error);
        return null;
      }
    }

    async function persistBooks(books, payload) {
      let storage;
      try {
        storage = window.localStorage;
      } catch (error) {
        console.warn('Local storage is not available', error);
        return;
      }
      if (!storage) {
        return;
      }
      try {
        const checksum = await hashPayload(payload);
        const cacheRecord = {
          version: BOOK_CACHE_VERSION,
          timestamp: Date.now(),
          checksum,
          books: books.map((book) => sanitizeBookForCache(book))
        };
        storage.setItem(BOOK_CACHE_KEY, JSON.stringify(cacheRecord));
        state.cacheChecksum = checksum;
      } catch (error) {
        console.warn('Failed to persist book cache', error);
      }
    }

    async function hashPayload(payload) {
      if (!window.crypto?.subtle) {
        return '';
      }
      let data;
      if (typeof payload === 'string') {
        data = new TextEncoder().encode(payload);
      } else if (payload instanceof ArrayBuffer) {
        data = new Uint8Array(payload);
      } else if (ArrayBuffer.isView(payload)) {
        data = new Uint8Array(payload.buffer);
      } else {
        return '';
      }
      const digest = await window.crypto.subtle.digest('SHA-256', data);
      return Array.from(new Uint8Array(digest))
        .map((byte) => byte.toString(16).padStart(2, '0'))
        .join('');
    }

    function sanitizeBookForCache(book) {
      if (!book || typeof book !== 'object') {
        return {};
      }
      const copy = { ...book };
      if (typeof copy.cover === 'string' && copy.cover.startsWith('data:image/')) {
        copy.cover = '';
      }
      return copy;
    }

    function parseTsv(text) {
      if (typeof text !== 'string') {
        return [];
      }
      const cleaned = text.replace(/^﻿/, '');
      const lines = cleaned.split(/\r?\n/);
      const headerIndex = lines.findIndex((line) => line.trim());
      if (headerIndex === -1) {
        return [];
      }
      const header = lines[headerIndex].split('\t').map((cell) => cell.trim());
      const rows = [];
      for (let i = headerIndex + 1; i < lines.length; i += 1) {
        const line = lines[i];
        if (!line || !line.trim()) {
          continue;
        }
        const cells = line.split('\t');
        const row = {};
        let hasValue = false;
        header.forEach((key, index) => {
          const value = (cells[index] || '').trim();
          if (value) {
            hasValue = true;
          }
          row[key] = value;
        });
        if (hasValue) {
          rows.push(row);
        }
      }
      return rows;
    }

    function convertSheetRowsToObjects(rawRows) {
      if (!Array.isArray(rawRows) || rawRows.length <= 1) {
        return [];
      }
      const width = rawRows.reduce((max, row) => Math.max(max, Array.isArray(row) ? row.length : 0), 0);
      if (width === 0) {
        return [];
      }
      const headerRow = rawRows[0];
      const normalizedHeaders = Array.from({ length: width }, (_, index) => {
        const cell = headerRow[index];
        if (typeof cell === 'string') {
          const trimmed = cell.trim();
          if (trimmed) {
            return trimmed;
          }
        }
        return '';
      });
      const result = [];
      for (let rowIndex = 1; rowIndex < rawRows.length; rowIndex += 1) {
        const row = Array.isArray(rawRows[rowIndex]) ? rawRows[rowIndex] : [];
        const record = {};
        let hasValue = false;
        for (let colIndex = 0; colIndex < width; colIndex += 1) {
          const value = row[colIndex] ?? '';
          const hasCellValue =
            typeof value === 'number'
              ? true
              : typeof value === 'string'
              ? Boolean(value.trim())
              : Boolean(value);
          if (hasCellValue) {
            hasValue = true;
          }
          const header = normalizedHeaders[colIndex];
          if (header) {
            record[header] = value;
          }
          record[`__COL_${getColumnLetter(colIndex)}`] = value;
        }
        record.__rowIndex = rowIndex;
        if (hasValue) {
          result.push(record);
        }
      }
      return result;
    }

    function getColumnLetter(index) {
      let letter = '';
      let current = Number(index);
      if (!Number.isFinite(current) || current < 0) {
        return '';
      }
      while (current >= 0) {
        letter = String.fromCharCode((current % 26) + 65) + letter;
        current = Math.floor(current / 26) - 1;
      }
      return letter;
    }

    function normalizeRow(row) {
      const getValue = (keys) => {
        for (const key of keys) {
          if (row[key] !== undefined && row[key] !== null) {
            const value = String(row[key]).trim();
            if (value) {
              return value;
            }
          }
        }
        return '';
      };
      const title = getValue(columnAliases.title);
      const author = getValue(columnAliases.author);
      const specialty = getValue(columnAliases.specialty);
      const { sanitizedLink, hasExternalLink } = normalizeLink(getValue(columnAliases.link), title, author);
      const rowIndex = typeof row.__rowIndex === 'number' ? row.__rowIndex : null;
      let coverValue = getValue(columnAliases.cover);
      if (!coverValue && rowIndex !== null) {
        coverValue = getExcelCover(rowIndex);
      }
      return {
        title,
        author,
        publisher: getValue(columnAliases.publisher),
        city: getValue(columnAliases.city),
        year: getValue(columnAliases.year),
        pages: getValue(columnAliases.pages),
        language: getValue(columnAliases.language),
        specialty,
        link: sanitizedLink,
        hasExternalLink,
        cover: resolveCoverValue(coverValue, title, author, specialty)
      };
    }

    function normalizeLink(value, title, author) {
      const trimmed = (value || '').trim();
      if (trimmed) {
        if (/^https?:\/\//i.test(trimmed)) {
          return { sanitizedLink: trimmed, hasExternalLink: true };
        }
        if (/^www\./i.test(trimmed)) {
          return { sanitizedLink: `https://${trimmed}`, hasExternalLink: true };
        }
      }
      const query = [title, author].filter(Boolean).join(' ').trim();
      const fallbackQuery = query || trimmed;
      const fallbackLink = `https://www.google.com/search?q=${encodeURIComponent(fallbackQuery || 'medical book')}`;
      return { sanitizedLink: fallbackLink, hasExternalLink: false };
    }

    function resolveCoverValue(value, title, author, specialty) {
      let source = value;
      const fallbackKey = [title, author, specialty].filter(Boolean).join(' | ');
      if (typeof source === 'string') {
        const trimmed = source.trim();
        if (!trimmed) {
          source = '';
        } else if ((trimmed.startsWith('{') || trimmed.startsWith('[')) && trimmed.length > 4) {
          try {
            const parsed = JSON.parse(trimmed);
            if (typeof parsed === 'string') {
              source = parsed;
            } else if (Array.isArray(parsed)) {
              source = parsed.find((item) => typeof item === 'string' && item.trim());
            } else if (parsed && typeof parsed.url === 'string') {
              source = parsed.url;
            }
          } catch (error) {
            console.warn('Unable to parse cover value', error);
          }
        } else {
          source = trimmed;
        }
      }
      return sanitizeUrl(source, getFallbackCover(fallbackKey));
    }

    function getExcelCover(rowIndex) {
      if (!excelImageMap || !excelImageMap.size) {
        return '';
      }
      const candidates = [rowIndex, rowIndex + 1, rowIndex - 1];
      for (const candidate of candidates) {
        if (Number.isInteger(candidate) && candidate >= 0 && excelImageMap.has(candidate)) {
          return excelImageMap.get(candidate);
        }
      }
      return '';
    }

    function sanitizeUrl(value, fallback) {
      if (!value || typeof value !== 'string') {
        return fallback;
      }
      const trimmed = value.trim();
      if (!trimmed) {
        return fallback;
      }
      if (/^(?:https?:|data:image|blob:)/i.test(trimmed)) {
        return trimmed;
      }
      if (/^(?:\.\/|\/)?[\w\-./]+\.(?:png|jpe?g|webp|gif|svg)$/i.test(trimmed)) {
        return trimmed.startsWith('./') || trimmed.startsWith('/') ? trimmed : `./${trimmed}`;
      }
      return fallback;
    }

    function getFallbackCover(key) {
      const normalized = (key || 'default').toLowerCase();
      if (fallbackCoverCache.has(normalized)) {
        return fallbackCoverCache.get(normalized);
      }
      const hash = hashString(normalized);
      const index = Math.abs(hash) % fallbackCoverImages.length;
      const url = `./${fallbackCoverImages[index]}`;
      fallbackCoverCache.set(normalized, url);
      return url;
    }

    function hashString(value) {
      let hash = 0;
      const str = value || '';
      for (let i = 0; i < str.length; i += 1) {
        hash = (hash << 5) - hash + str.charCodeAt(i);
        hash |= 0;
      }
      return hash;
    }

    async function extractExcelImages(buffer) {
      if (typeof JSZip === 'undefined' || typeof DOMParser === 'undefined') {
        return new Map();
      }
      try {
        const zip = await JSZip.loadAsync(buffer);
        const parser = new DOMParser();
        const workbookPath = 'xl/workbook.xml';
        const workbookXml = await loadZipText(zip, workbookPath);
        if (!workbookXml) {
          return new Map();
        }
        const workbookDoc = parser.parseFromString(workbookXml, 'application/xml');
        const firstSheet = workbookDoc.querySelector('sheet');
        if (!firstSheet) {
          return new Map();
        }
        const sheetRelId = firstSheet.getAttribute('r:id');
        if (!sheetRelId) {
          return new Map();
        }
        const workbookRelsXml = await loadZipText(zip, getRelationshipPath(workbookPath));
        if (!workbookRelsXml) {
          return new Map();
        }
        const workbookRelsDoc = parser.parseFromString(workbookRelsXml, 'application/xml');
        const sheetRelNode = workbookRelsDoc.querySelector(`Relationship[Id="${sheetRelId}"]`);
        const sheetTarget = sheetRelNode?.getAttribute('Target');
        if (!sheetTarget) {
          return new Map();
        }
        const sheetPath = resolveZipTarget(workbookPath, sheetTarget);
        const sheetRelsPath = getRelationshipPath(sheetPath);
        const sheetRelsXml = await loadZipText(zip, sheetRelsPath);
        if (!sheetRelsXml) {
          return new Map();
        }
        const sheetRelsDoc = parser.parseFromString(sheetRelsXml, 'application/xml');
        const drawingRelNode = sheetRelsDoc.querySelector(`Relationship[Type="${DRAWING_REL_TYPE}"]`);
        const drawingTarget = drawingRelNode?.getAttribute('Target');
        if (!drawingTarget) {
          return new Map();
        }
        const drawingPath = resolveZipTarget(sheetRelsPath, drawingTarget);
        const drawingXml = await loadZipText(zip, drawingPath);
        const drawingRelsPath = getRelationshipPath(drawingPath);
        const drawingRelsXml = await loadZipText(zip, drawingRelsPath);
        if (!drawingXml || !drawingRelsXml) {
          return new Map();
        }
        const drawingDoc = parser.parseFromString(drawingXml, 'application/xml');
        const drawingRelsDoc = parser.parseFromString(drawingRelsXml, 'application/xml');
        const relationshipMap = new Map();
        drawingRelsDoc.querySelectorAll('Relationship').forEach((node) => {
          const relId = node.getAttribute('Id');
          const relTarget = node.getAttribute('Target');
          if (relId && relTarget) {
            relationshipMap.set(relId, resolveZipTarget(drawingRelsPath, relTarget));
          }
        });
        const anchors = [
          ...drawingDoc.getElementsByTagNameNS(XDR_NS, 'oneCellAnchor'),
          ...drawingDoc.getElementsByTagNameNS(XDR_NS, 'twoCellAnchor')
        ];
        const map = new Map();
        for (const anchor of anchors) {
          const fromNode = anchor.getElementsByTagNameNS(XDR_NS, 'from')[0];
          const picNode = anchor.getElementsByTagNameNS(XDR_NS, 'pic')[0];
          if (!fromNode || !picNode) {
            continue;
          }
          const rowNode = fromNode.getElementsByTagNameNS(XDR_NS, 'row')[0];
          if (!rowNode) {
            continue;
          }
          const rowIndex = Number.parseInt(rowNode.textContent || '', 10);
          if (!Number.isFinite(rowIndex)) {
            continue;
          }
          if (map.has(rowIndex)) {
            continue;
          }
          const blip = picNode.getElementsByTagNameNS(DRAWING_NS, 'blip')[0];
          if (!blip) {
            continue;
          }
          const relId = blip.getAttributeNS(EXCEL_REL_NS, 'embed');
          if (!relId) {
            continue;
          }
          const mediaPath = relationshipMap.get(relId);
          if (!mediaPath) {
            continue;
          }
          const normalizedPath = mediaPath.replace(/^\//, '');
          const fileEntry = zip.file(normalizedPath);
          if (!fileEntry) {
            continue;
          }
          const bytes = await fileEntry.async('uint8array');
          if (!bytes || !bytes.length) {
            continue;
          }
          const mimeType = getMimeTypeFromPath(normalizedPath);
          map.set(rowIndex, `data:${mimeType};base64,${uint8ArrayToBase64(bytes)}`);
        }
        return map;
      } catch (error) {
        console.warn('Failed to extract Excel images', error);
        return new Map();
      }
    }

    async function loadZipText(zip, path) {
      if (!zip || !path) {
        return '';
      }
      const normalized = path.replace(/^\//, '');
      const fileEntry = zip.file(normalized);
      if (!fileEntry) {
        return '';
      }
      return fileEntry.async('string');
    }

    function resolveZipTarget(basePath, target) {
      if (!target) {
        return '';
      }
      if (target.startsWith('/')) {
        return target.slice(1);
      }
      const baseParts = basePath.split('/');
      baseParts.pop();
      const segments = target.split('/');
      for (const segment of segments) {
        if (!segment || segment === '.') {
          continue;
        }
        if (segment === '..') {
          if (baseParts.length) {
            baseParts.pop();
          }
        } else {
          baseParts.push(segment);
        }
      }
      return baseParts.join('/');
    }

    function getRelationshipPath(filePath) {
      if (!filePath) {
        return '';
      }
      const lastSlash = filePath.lastIndexOf('/');
      const dir = lastSlash === -1 ? '' : filePath.slice(0, lastSlash + 1);
      const fileName = lastSlash === -1 ? filePath : filePath.slice(lastSlash + 1);
      return `${dir}_rels/${fileName}.rels`;
    }

    function getMimeTypeFromPath(path) {
      if (!path) {
        return 'image/png';
      }
      const extension = path.split('.').pop()?.toLowerCase();
      switch (extension) {
        case 'jpg':
        case 'jpeg':
          return 'image/jpeg';
        case 'gif':
          return 'image/gif';
        case 'webp':
          return 'image/webp';
        case 'png':
        default:
          return 'image/png';
      }
    }

    function uint8ArrayToBase64(bytes) {
      if (!bytes || !bytes.length) {
        return '';
      }
      let binary = '';
      const chunkSize = 0x8000;
      for (let index = 0; index < bytes.length; index += chunkSize) {
        const chunk = bytes.subarray(index, index + chunkSize);
        binary += String.fromCharCode.apply(null, Array.from(chunk));
      }
      return btoa(binary);
    }

    function escapeHtml(value) {
      return String(value || '')
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    function renderBooks() {
      const grid = document.getElementById('book-grid');
      if (!grid) return;
      const dict = translations[state.lang] || translations.ru;
      const books = getFilteredBooks();
      if (!state.books.length) {
        grid.innerHTML = `<div class="empty-state">${dict.statusLoading}</div>`;
        updateStatus('statusLoading');
        return;
      }
      grid.innerHTML = '';
      if (!books.length) {
        grid.innerHTML = `<div class="empty-state">${dict.statusEmpty}</div>`;
      } else {
        const fragment = document.createDocumentFragment();
        books.forEach((book) => {
          fragment.appendChild(createBookCard(book, dict));
        });
        grid.appendChild(fragment);
      }
      updateCountStatus(books.length, state.books.length);
      hydrateCoverImages();
    }

    function getFilteredBooks() {
      return state.books.filter((book) => {
        const normalizedTitle = normalizeText(book.title);
        if (state.filters.title && !normalizedTitle.includes(state.filters.title)) {
          return false;
        }
        const normalizedAuthor = normalizeText(book.author);
        if (state.filters.author && !normalizedAuthor.includes(state.filters.author)) {
          return false;
        }
        const normalizedYear = normalizeText(book.year);
        if (state.filters.year && !normalizedYear.includes(state.filters.year)) {
          return false;
        }
        const normalizedSpecialty = normalizeText(book.specialty);
        const normalizedSpecialtyTm = normalizeText(translateSpecialty(book.specialty));
        if (
          state.filters.specialty &&
          !normalizedSpecialty.includes(state.filters.specialty) &&
          !normalizedSpecialtyTm.includes(state.filters.specialty)
        ) {
          return false;
        }
        const normalizedLanguage = normalizeText(book.language);
        if (state.filters.language && !normalizedLanguage.includes(state.filters.language)) {
          return false;
        }
        return true;
      });
    }

    function createBookCard(book, dict) {
      const article = document.createElement('article');
      article.className = 'book-card';
      const specialty = book.specialty || dict.cardSpecialtyEmpty;
      const language = book.language || dict.cardLanguageEmpty;
      const targetLink = book.link || `https://www.google.com/search?q=${encodeURIComponent((book.title || '') + ' ' + (book.author || ''))}`;
      const isExternal = book.hasExternalLink === true && Boolean(book.link);
      const safeTitle = escapeHtml(book.title || dict.cardSpecialtyEmpty);
      const safeAuthor = escapeHtml(book.author || '—');
      const safeLanguage = escapeHtml(language);
      const safePublisher = escapeHtml(book.publisher || '—');
      const safeCity = escapeHtml(book.city || '—');
      const safePages = escapeHtml(book.pages || '—');
      const safeYear = escapeHtml(book.year || dict.cardYear);
      const safeSpecialty = escapeHtml(specialty);
      const coverSource = escapeHtml(book.cover || getFallbackCover(book.title || book.author || specialty || 'default'));
      const coverQuery = [book.title, book.author, book.specialty]
        .filter((value) => Boolean(value && value.trim()))
        .join(' ')
        .trim();
      const coverAlt = escapeHtml(book.title || dict.cardCoverAlt);
      article.innerHTML = `
        <div class="book-card__media">
          <img src="${coverSource}" alt="${coverAlt}" loading="lazy" decoding="async">
        </div>
        <div class="book-card__top">
          <span class="book-card__chip">${safeSpecialty}</span>
          <span class="book-card__chip">${safeYear}</span>
        </div>
        <div>
          <h3 class="book-card__title">${safeTitle}</h3>
          <p class="book-card__author">${dict.cardAuthor}: ${safeAuthor}</p>
        </div>
        <div class="book-card__details">
          <div>
            <span class="book-card__label">${dict.cardLanguage}</span>
            <strong>${safeLanguage}</strong>
          </div>
          <div>
            <span class="book-card__label">${dict.cardPublisher}</span>
            <strong>${safePublisher}</strong>
          </div>
          <div>
            <span class="book-card__label">${dict.cardCity}</span>
            <strong>${safeCity}</strong>
          </div>
          <div>
            <span class="book-card__label">${dict.cardPages}</span>
            <strong>${safePages}</strong>
          </div>
        </div>
      `;
      const actions = document.createElement('div');
      actions.className = 'book-card__actions';
      const button = document.createElement('a');
      button.className = 'book-card__link';
      button.textContent = isExternal ? dict.cardOpen : dict.cardSearch;
      button.href = targetLink;
      button.target = '_blank';
      button.rel = 'noopener';
      actions.appendChild(button);
      article.appendChild(actions);
      const image = article.querySelector('.book-card__media img');
      if (image && coverQuery) {
        image.dataset.coverQuery = coverQuery;
        image.dataset.coverTitle = book.title || '';
        image.dataset.coverAuthor = book.author || '';
      }
      return article;
    }

    function hydrateCoverImages() {
      const images = document.querySelectorAll('.book-card__media img[data-cover-query]');
      images.forEach((image) => {
        if (!image || image.dataset.coverHydrated === 'true') {
          return;
        }
        if (coverObserver) {
          coverObserver.observe(image);
        } else {
          upgradeCoverImage(image);
        }
      });
    }

    async function upgradeCoverImage(image) {
      if (!image || image.dataset.coverHydrated === 'true') {
        return;
      }
      const rawQuery = image.dataset.coverQuery || `${image.dataset.coverTitle || ''} ${image.dataset.coverAuthor || ''}`;
      const cacheKey = normalizeText(rawQuery);
      if (!cacheKey) {
        return;
      }
      const cached = getCachedCover(cacheKey);
      if (cached) {
        image.src = cached;
        image.dataset.coverHydrated = 'true';
        return;
      }
      if (!coverFetchPromises.has(cacheKey)) {
        coverFetchPromises.set(cacheKey, fetchRemoteCover(image.dataset.coverTitle, image.dataset.coverAuthor));
      }
      try {
        const remoteUrl = await coverFetchPromises.get(cacheKey);
        if (remoteUrl) {
          const finalUrl = await persistCoverLocally(remoteUrl, cacheKey);
          image.src = finalUrl;
          image.dataset.coverHydrated = 'true';
          cacheRemoteCover(cacheKey, finalUrl);
        }
      } catch (error) {
        console.warn('Unable to load remote cover', error);
      } finally {
        coverFetchPromises.delete(cacheKey);
      }
    }

    function ensureRemoteCoverCache() {
      if (remoteCoverCacheLoaded) {
        return;
      }
      remoteCoverCacheLoaded = true;
      try {
        const raw = localStorage.getItem(REMOTE_COVER_CACHE_KEY);
        if (!raw) {
          return;
        }
        const parsed = JSON.parse(raw);
        if (parsed?.version !== REMOTE_COVER_CACHE_VERSION || !Array.isArray(parsed?.entries)) {
          return;
        }
        parsed.entries.forEach(([key, value]) => {
          if (typeof key === 'string' && typeof value === 'string') {
            remoteCoverCache.set(key, value);
          }
        });
      } catch (error) {
        console.warn('Unable to parse cover cache', error);
      }
    }

    function getCachedCover(key) {
      if (!key) {
        return '';
      }
      ensureRemoteCoverCache();
      return remoteCoverCache.get(key) || '';
    }

    const scheduleCoverCachePersist = (() => {
      let pending = false;
      return () => {
        if (pending) {
          return;
        }
        pending = true;
        idleCallback(() => {
          pending = false;
          persistCoverCache();
        });
      };
    })();

    function cacheRemoteCover(key, url) {
      if (!key || !url) {
        return;
      }
      ensureRemoteCoverCache();
      remoteCoverCache.set(key, url);
      scheduleCoverCachePersist();
    }

    async function persistCoverLocally(url, cacheKey) {
      if (!url || !API_BASE) {
        return url;
      }

      try {
        const response = await fetch(`${API_BASE}/covers/cache`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ url, key: cacheKey })
        });

        if (!response.ok) {
          return url;
        }

        const payload = await response.json();
        return payload?.localUrl || url;
      } catch (error) {
        console.warn('Unable to persist cover', error);
        return url;
      }
    }

    function persistCoverCache() {
      if (!remoteCoverCacheLoaded) {
        return;
      }
      const entries = Array.from(remoteCoverCache.entries()).slice(-200);
      try {
        localStorage.setItem(
          REMOTE_COVER_CACHE_KEY,
          JSON.stringify({ version: REMOTE_COVER_CACHE_VERSION, entries })
        );
      } catch (error) {
        console.warn('Unable to persist cover cache', error);
      }
    }

    async function fetchRemoteCover(title, author) {
      const normalizedTitle = (title || '').trim();
      const normalizedAuthor = (author || '').trim();
      if (!normalizedTitle && !normalizedAuthor) {
        return '';
      }
      const params = new URLSearchParams({ limit: '1' });
      if (normalizedTitle) {
        params.set('title', title);
      }
      if (normalizedAuthor) {
        params.set('author', author);
      }
      const controller = new AbortController();
      const timeoutId = window.setTimeout(() => controller.abort(), 4500);
      try {
        const response = await fetch(`https://openlibrary.org/search.json?${params.toString()}`, {
          signal: controller.signal
        });
        if (!response.ok) {
          throw new Error('Network error while fetching cover');
        }
        const payload = await response.json();
        const doc = payload?.docs?.[0];
        if (doc?.cover_i) {
          return `https://covers.openlibrary.org/b/id/${doc.cover_i}-L.jpg`;
        }
        if (Array.isArray(doc?.isbn) && doc.isbn.length) {
          return `https://covers.openlibrary.org/b/isbn/${encodeURIComponent(doc.isbn[0])}-L.jpg`;
        }
        return '';
      } finally {
        window.clearTimeout(timeoutId);
      }
    }

    function updateStatus(key) {
      const pill = document.getElementById('status-pill');
      if (!pill) return;
      const dict = translations[state.lang] || translations.ru;
      const template = dict[key];
      pill.textContent = template || '';
    }

    function updateCountStatus(count, total) {
      const pill = document.getElementById('status-pill');
      if (!pill) return;
      const dict = translations[state.lang] || translations.ru;
      const key = count === total ? 'statusTotal' : 'statusFiltered';
      const template = dict[key] || '';
      pill.textContent = template.replace('{count}', count).replace('{total}', total);
    }
  </script>
  <script src="pwa.js"></script>
</body>
</html>
