<!DOCTYPE html>
<html lang="ru" data-lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#0d47a1">
  <title>Медицинская электронная библиотека — книги</title>
  <link rel="manifest" href="/MedLibrary/manifest.webmanifest">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      color-scheme: light;
      --bg: #f5f6fb;
      --card-bg: #ffffff;
      --primary: #0b6efd;
      --primary-dark: #084298;
      --text: #1f2a37;
      --muted: #5f6b7c;
      --border: #d9e0ec;
      --shadow: 0 12px 32px rgba(15, 23, 42, 0.08);
      --chip-bg: #e7f1ff;
      --chip-text: #1c4ed8;
      font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      background: var(--bg);
      color: var(--text);
      line-height: 1.6;
    }

    a {
      color: var(--primary);
      text-decoration: none;
    }

    .site-header {
      background: var(--card-bg);
      padding: 1.5rem clamp(1rem, 4vw, 4rem);
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      align-items: center;
      gap: 1rem;
      box-shadow: 0 1px 0 rgba(15, 23, 42, 0.08);
      position: sticky;
      top: 0;
      z-index: 10;
    }

    .logo-area {
      display: flex;
      flex-direction: column;
      gap: 0.2rem;
    }

    .logo-area__eyebrow {
      font-size: 0.9rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .logo-area__title {
      font-size: clamp(1.5rem, 2vw, 2rem);
      margin: 0;
    }

    .language-switcher {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-weight: 500;
    }

    select {
      border-radius: 999px;
      border: 1px solid var(--border);
      padding: 0.4rem 1.2rem;
      font-size: 1rem;
      font-family: inherit;
      background: #fff;
      color: var(--text);
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }

    select:focus-visible, input:focus-visible {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(11, 110, 253, 0.15);
    }

    nav {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      padding: 0.75rem clamp(1rem, 4vw, 4rem);
      background: transparent;
    }

    nav a {
      font-weight: 500;
      color: var(--muted);
      padding: 0.25rem 0.5rem;
      border-radius: 999px;
      transition: color 0.2s ease, background 0.2s ease;
    }

    nav a:hover,
    nav a:focus-visible {
      color: var(--primary);
      background: rgba(11, 110, 253, 0.08);
    }

    main {
      padding: 2rem clamp(1rem, 4vw, 4rem) 4rem;
      display: flex;
      flex-direction: column;
      gap: 2rem;
    }

    .filter-panel {
      background: var(--card-bg);
      border-radius: 24px;
      padding: clamp(1.5rem, 3vw, 2.5rem);
      box-shadow: var(--shadow);
    }

    .filter-panel__head {
      margin-bottom: 1.5rem;
    }

    .filter-panel__title {
      margin: 0 0 0.3rem;
      font-size: clamp(1.5rem, 2vw, 2rem);
    }

    .filter-panel__subtitle {
      margin: 0;
      color: var(--muted);
    }

    .filter-form {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 1rem;
      align-items: end;
    }

    .filter-field {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
      font-weight: 500;
      color: var(--muted);
    }

    .filter-field input {
      border-radius: 14px;
      border: 1px solid var(--border);
      padding: 0.85rem 1rem;
      font-size: 1rem;
      font-family: inherit;
      transition: border-color 0.2s ease, box-shadow 0.2s ease, transform 0.2s ease;
      background: #fdfdff;
    }

    .filter-field input:hover {
      transform: translateY(-1px);
      border-color: var(--primary);
    }

    .filter-actions {
      display: flex;
      gap: 0.75rem;
      flex-wrap: wrap;
      margin-top: 0.5rem;
    }

    .button {
      border: none;
      border-radius: 14px;
      padding: 0.85rem 1.5rem;
      font-size: 1rem;
      font-weight: 600;
      font-family: inherit;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
    }

    .button--primary {
      background: var(--primary);
      color: #fff;
      box-shadow: 0 12px 20px rgba(11, 110, 253, 0.25);
    }

    .button--primary:hover {
      transform: translateY(-2px);
      background: var(--primary-dark);
    }

    .button--ghost {
      background: rgba(15, 23, 42, 0.06);
      color: var(--text);
    }

    .status-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 1rem;
      flex-wrap: wrap;
    }

    .status-pill {
      background: var(--card-bg);
      border-radius: 999px;
      padding: 0.35rem 0.95rem;
      color: var(--muted);
      font-weight: 500;
      box-shadow: 0 8px 18px rgba(15, 23, 42, 0.08);
    }

    .book-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 1.5rem;
    }

    .book-card {
      background: var(--card-bg);
      border-radius: 24px;
      padding: 1.5rem;
      box-shadow: var(--shadow);
      display: flex;
      flex-direction: column;
      gap: 1rem;
      transition: transform 0.25s ease, box-shadow 0.25s ease;
      min-height: 280px;
    }

    .book-card__media {
      width: 100%;
      aspect-ratio: 3 / 4;
      border-radius: 18px;
      overflow: hidden;
      position: relative;
      background: linear-gradient(135deg, rgba(11, 110, 253, 0.15), rgba(15, 23, 42, 0.15));
      box-shadow: inset 0 0 0 1px rgba(15, 23, 42, 0.04);
    }

    .book-card__media img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    .book-card:hover {
      transform: translateY(-6px) scale(1.01);
      box-shadow: 0 20px 35px rgba(15, 23, 42, 0.15);
    }

    .book-card__top {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .book-card__chip {
      background: var(--chip-bg);
      color: var(--chip-text);
      padding: 0.2rem 0.85rem;
      border-radius: 999px;
      font-size: 0.85rem;
      font-weight: 600;
    }

    .book-card__title {
      margin: 0;
      font-size: 1.15rem;
      line-height: 1.4;
    }

    .book-card__author {
      margin: 0;
      color: var(--muted);
      font-size: 0.95rem;
    }

    .book-card__details {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 0.65rem 1rem;
      font-size: 0.9rem;
    }

    .book-card__label {
      color: var(--muted);
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      display: block;
    }

    .book-card__actions {
      margin-top: auto;
      display: flex;
      gap: 0.75rem;
      flex-wrap: wrap;
    }

    .book-card__link {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.4rem;
      border-radius: 14px;
      padding: 0.7rem 1.2rem;
      font-weight: 600;
      background: var(--primary);
      color: #fff;
      transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
      flex: 1;
      min-width: 160px;
    }

    .book-card__link:hover {
      transform: translateY(-2px);
      background: var(--primary-dark);
      box-shadow: 0 15px 20px rgba(11, 110, 253, 0.2);
    }

    .book-card__link[aria-disabled="true"] {
      cursor: not-allowed;
      background: rgba(15, 23, 42, 0.12);
      box-shadow: none;
    }

    .empty-state {
      grid-column: 1 / -1;
      background: rgba(11, 110, 253, 0.08);
      color: var(--primary-dark);
      padding: 2rem;
      border-radius: 24px;
      text-align: center;
      font-weight: 600;
    }

    footer {
      background: #0f172a;
      color: rgba(255, 255, 255, 0.8);
      padding: 2.5rem clamp(1rem, 4vw, 4rem);
      margin-top: 3rem;
    }

    .footer-content {
      display: flex;
      flex-wrap: wrap;
      gap: 2rem;
      justify-content: space-between;
    }

    .footer-content a {
      color: #fff;
      font-weight: 600;
    }

    @media (max-width: 720px) {
      .book-card__details {
        grid-template-columns: 1fr;
      }

      .site-header {
        position: static;
      }
    }
  </style>
</head>
<body>
  <header class="site-header">
    <div class="logo-area">
      <span class="logo-area__eyebrow" data-i18n="tagline">Медицинская электронная библиотека</span>
      <h1 class="logo-area__title" data-i18n="heroTitle">Каталог медицинских книг</h1>
    </div>
    <div class="language-switcher">
      <label for="language-select" data-i18n="languageLabel">Язык интерфейса:</label>
      <select id="language-select" aria-label="Select interface language">
        <option value="tm">Türkmençe</option>
        <option value="ru" selected>Русский</option>
        <option value="en">English</option>
      </select>
    </div>
  </header>
  <nav aria-label="Primary">
    <a href="index.html" data-i18n="navHome">Главная</a>
    <a href="BookCategory.html" data-i18n="navCategories">Категории</a>
    <a href="book.html" aria-current="page" data-i18n="navBooks">Каталог книг</a>
    <a href="https://sites.google.com/view/lukmanylyksanlykitaphanasy/ba%C5%9F-sahypa" target="_blank" rel="noopener" data-i18n="navAltSite">Другой сайт библиотеки</a>
  </nav>
  <main>
    <section class="filter-panel" aria-labelledby="filter-title">
      <div class="filter-panel__head">
        <p class="logo-area__eyebrow" data-i18n="filterEyebrow">Фильтр книг</p>
        <h2 id="filter-title" class="filter-panel__title" data-i18n="filterTitle">Найдите нужную литературу</h2>
        <p class="filter-panel__subtitle" data-i18n="filterSubtitle">Используйте отдельные поля ниже, чтобы быстро отфильтровать книги по названию, автору, году, разделу и языку.</p>
      </div>
      <div class="filter-form" id="filter-form">
        <label class="filter-field">
          <span data-i18n="labelTitle">Название книги</span>
          <input type="text" data-filter="title" data-i18n-placeholder="placeholderTitle" placeholder="Например: нейрохирургия" autocomplete="off">
        </label>
        <label class="filter-field">
          <span data-i18n="labelAuthor">Автор</span>
          <input type="text" data-filter="author" data-i18n-placeholder="placeholderAuthor" placeholder="Например: Apuzzo" autocomplete="off">
        </label>
        <label class="filter-field">
          <span data-i18n="labelYear">Год издания</span>
          <input type="text" inputmode="numeric" data-filter="year" data-i18n-placeholder="placeholderYear" placeholder="Например: 2018" autocomplete="off">
        </label>
        <label class="filter-field">
          <span data-i18n="labelSpecialty">Специальность / раздел</span>
          <input type="text" data-filter="specialty" data-i18n-placeholder="placeholderSpecialty" placeholder="Например: нейрохирургия" autocomplete="off">
        </label>
        <label class="filter-field">
          <span data-i18n="labelLanguage">Язык</span>
          <input type="text" data-filter="language" data-i18n-placeholder="placeholderLanguage" placeholder="Например: EN" autocomplete="off">
        </label>
      </div>
      <div class="filter-actions">
        <button class="button button--primary" type="button" id="reset-filters" data-i18n="reset">Сбросить фильтры</button>
      </div>
    </section>
    <section class="status-bar">
      <span class="status-pill" id="status-pill">—</span>
    </section>
    <section id="book-grid" class="book-grid" aria-live="polite"></section>
  </main>
  <footer>
    <div class="footer-content">
      <div>
        <strong data-i18n="contactTitle">Контакты</strong>
        <p><span data-i18n="contactPhone">Телефон:</span> <a href="tel:+99362234094">+993 62 23 40 94</a></p>
        <p><span data-i18n="contactEmail">Email:</span> <a href="mailto:tdlipf@gmail.com">tdlipf@gmail.com</a></p>
      </div>
      <div>
        <strong data-i18n="footerNavigation">Навигация</strong>
        <p><a href="index.html" data-i18n="navHome">Главная</a></p>
        <p><a href="BookCategory.html" data-i18n="navCategories">Категории</a></p>
      </div>
      <div>
        <strong data-i18n="footerRights">© 2025 Медицинская электронная библиотека</strong>
        <p data-i18n="footerText">Все права защищены. Проект создан для удобного доступа к медицинской литературе.</p>
      </div>
    </div>
  </footer>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.19.3/dist/xlsx.full.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script>
    const translations = {
      ru: {
        pageTitle: 'Медицинская электронная библиотека — книги',
        tagline: 'Медицинская электронная библиотека',
        heroTitle: 'Каталог медицинских книг',
        languageLabel: 'Язык интерфейса:',
        navHome: 'Главная',
        navCategories: 'Категории',
        navBooks: 'Каталог книг',
        navAltSite: 'Другой сайт библиотеки',
        filterEyebrow: 'Фильтр книг',
        filterTitle: 'Найдите нужную литературу',
        filterSubtitle: 'Используйте отдельные поля ниже, чтобы быстро отфильтровать книги по названию, автору, году, разделу и языку.',
        labelTitle: 'Название книги',
        labelAuthor: 'Автор',
        labelYear: 'Год издания',
        labelSpecialty: 'Специальность / раздел',
        labelLanguage: 'Язык',
        placeholderTitle: 'Например: нейрохирургия',
        placeholderAuthor: 'Например: Apuzzo',
        placeholderYear: 'Например: 2018',
        placeholderSpecialty: 'Например: радиология',
        placeholderLanguage: 'Например: EN',
        reset: 'Сбросить фильтры',
        statusLoading: 'Загружаем каталог...',
        statusEmpty: 'Ничего не найдено',
        statusTotal: 'Всего книг: {count}',
        statusFiltered: 'Найдено {count} из {total}',
        cardSpecialty: 'Раздел',
        cardYear: 'Год',
        cardLanguage: 'Язык',
        cardAuthor: 'Автор',
        cardCity: 'Город',
        cardPublisher: 'Издательство',
        cardPages: 'Страниц',
        cardOpen: 'Открыть файл',
        cardSearch: 'Найти книгу',
        cardCoverAlt: 'Обложка книги',
        cardSpecialtyEmpty: 'Не указано',
        cardLanguageEmpty: '—',
        contactTitle: 'Контакты',
        contactPhone: 'Телефон:',
        contactEmail: 'Email:',
        footerNavigation: 'Навигация',
        footerRights: '© 2025 Медицинская электронная библиотека',
        footerText: 'Все права защищены. Проект создан для удобного доступа к медицинской литературе.'
      },
      en: {
        pageTitle: 'Medical e-Library — books',
        tagline: 'Medical digital library',
        heroTitle: 'Medical book catalogue',
        languageLabel: 'Interface language:',
        navHome: 'Home',
        navCategories: 'Book categories',
        navBooks: 'Book list',
        navAltSite: 'Alternative library site',
        filterEyebrow: 'Book filters',
        filterTitle: 'Find the right resource',
        filterSubtitle: 'Use the dedicated fields below to filter books by title, author, year, specialty and language in real time.',
        labelTitle: 'Book title',
        labelAuthor: 'Author',
        labelYear: 'Year',
        labelSpecialty: 'Specialty / section',
        labelLanguage: 'Language',
        placeholderTitle: 'e.g. neurosurgery',
        placeholderAuthor: 'e.g. Apuzzo',
        placeholderYear: 'e.g. 2018',
        placeholderSpecialty: 'e.g. radiology',
        placeholderLanguage: 'e.g. EN',
        reset: 'Reset filters',
        statusLoading: 'Loading catalogue...',
        statusEmpty: 'No books match your filters',
        statusTotal: 'Total books: {count}',
        statusFiltered: 'Showing {count} of {total}',
        cardSpecialty: 'Specialty',
        cardYear: 'Year',
        cardLanguage: 'Language',
        cardAuthor: 'Author',
        cardCity: 'City',
        cardPublisher: 'Publisher',
        cardPages: 'Pages',
        cardOpen: 'Open file',
        cardSearch: 'Search online',
        cardCoverAlt: 'Book cover',
        cardSpecialtyEmpty: 'Not specified',
        cardLanguageEmpty: '—',
        contactTitle: 'Contacts',
        contactPhone: 'Phone:',
        contactEmail: 'Email:',
        footerNavigation: 'Navigation',
        footerRights: '© 2025 Medical e-Library',
        footerText: 'All rights reserved. The project was created to provide convenient access to medical literature.'
      },
      tm: {
        pageTitle: 'Lukmançylyk elektron kitaphanasy — kitaplar',
        tagline: 'Lukmançylyk elektron kitaphanasy',
        heroTitle: 'Lukmançylyk kitaplarynyň katalogy',
        languageLabel: 'Interfeýsiň dili:',
        navHome: 'Baş sahypa',
        navCategories: 'Kategoriýalar',
        navBooks: 'Kitap katalogy',
        navAltSite: 'Kitaphananyň beýleki sahypasy',
        filterEyebrow: 'Kitap süzgüçleri',
        filterTitle: 'Gerek kitaby tapyň',
        filterSubtitle: 'Aşakdaky meýdançalar arkaly kitabyny ady, awtory, ýyly, ugry we dili boýunça dessine saýlap bilersiňiz.',
        labelTitle: 'Kitabyň ady',
        labelAuthor: 'Awtor',
        labelYear: 'Çykan ýyly',
        labelSpecialty: 'Ugry / bölüm',
        labelLanguage: 'Dil',
        placeholderTitle: 'Mysal üçin: neýrohirurgiýa',
        placeholderAuthor: 'Mysal üçin: Apuzzo',
        placeholderYear: 'Mysal üçin: 2018',
        placeholderSpecialty: 'Mysal üçin: radiologiýa',
        placeholderLanguage: 'Mysal üçin: TM',
        reset: 'Süzgüçleri arassala',
        statusLoading: 'Katalog ýüklenýär...',
        statusEmpty: 'Talaplara laýyk kitap tapylmady',
        statusTotal: 'Jemi kitap: {count}',
        statusFiltered: '{total} kitabyň {count}-si görkezildi',
        cardSpecialty: 'Ugry',
        cardYear: 'Ýyl',
        cardLanguage: 'Dil',
        cardAuthor: 'Awtor',
        cardCity: 'Şäher',
        cardPublisher: 'Neşirýat',
        cardPages: 'Sahypa',
        cardOpen: 'Faýly aç',
        cardSearch: 'Internetden tap',
        cardCoverAlt: 'Kitabyň suraty',
        cardSpecialtyEmpty: 'Görkezilmedik',
        cardLanguageEmpty: '—',
        contactTitle: 'Habarlaşmak üçin',
        contactPhone: 'Telefon:',
        contactEmail: 'Email:',
        footerNavigation: 'Ugrukdyrmak',
        footerRights: '© 2025 Lukmançylyk elektron kitaphanasy',
        footerText: 'Ähli hukuklar goralan. Taslama lukmançylyk edebiýatyna amatly elýeterlik üçin döredildi.'
      }
    };

    const columnAliases = {
      title: ['Название книги', 'Book Name', 'Book Title', 'Kitaplar', 'Kitabyň ady', 'Name'],
      author: ['Имя автора', 'Authors Name', 'Author', 'Awtoryň ady'],
      publisher: ['Издатель', 'Publisher', 'Neşirçi'],
      city: ['Город публикации', 'Publication City', 'City', 'Şäher'],
      year: ['Год публикации', 'Publication Year', 'Год', 'Year', 'Ýyl'],
      pages: ['Количество страниц', 'Page Count', 'Pages', 'Sahypalar'],
      language: ['Язык книги', 'Book Language', 'Dil', 'Language'],
      specialty: ['Специальность', 'Специальность / раздел', 'Раздел', 'Категория', 'Category', 'Specialty', 'Bölüm', 'Ugry'],
      link: ['Ссылка', 'Link', 'URL', 'Download', 'Файл', 'File'],
      cover: ['Обложка', 'Изображение', 'Фото', 'Cover', 'Image', 'Book image', 'H', '__COL_H']
    };

    const BOOK_CACHE_KEY = 'medlibrary.bookCache';
    const BOOK_CACHE_VERSION = '2.0.0';
    const BOOK_CACHE_TTL = 1000 * 60 * 60 * 12; // 12 hours
    const excelSources = ['Book.xlsx'];
    const fallbackCoverImages = ['1.webp', '2.webp', '3.webp', '4.webp', '5.webp', '6.webp', '1.png', '2.png', '3.png', '4.png', '5.png', '6.png'];
    const fallbackCoverCache = new Map();
    const accentPattern = /[\u0300-\u036f]/g;
    const REMOTE_COVER_CACHE_KEY = 'medlibrary.remoteCovers';
    const REMOTE_COVER_CACHE_VERSION = '1';
    const remoteCoverCache = new Map();
    const coverFetchPromises = new Map();
    const idleCallback = window.requestIdleCallback || ((cb) => window.setTimeout(cb, 280));
    let remoteCoverCacheLoaded = false;
    let coverObserver = null;
    if (typeof IntersectionObserver !== 'undefined') {
      coverObserver = new IntersectionObserver((entries, observer) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            observer.unobserve(entry.target);
            upgradeCoverImage(entry.target);
          }
        });
      }, { rootMargin: '200px' });
    }
    let excelImageMap = new Map();
    const EXCEL_REL_NS = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships';
    const DRAWING_REL_TYPE = `${EXCEL_REL_NS}/drawing`;
    const XDR_NS = 'http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing';
    const DRAWING_NS = 'http://schemas.openxmlformats.org/drawingml/2006/main';

    const state = {
      lang: document.documentElement.lang || 'ru',
      books: [],
      cacheChecksum: '',
      filters: {
        title: '',
        author: '',
        year: '',
        specialty: '',
        language: ''
      }
    };

    function normalizeText(value) {
      if (typeof value !== 'string') {
        value = value == null ? '' : String(value);
      }
      return value.trim().toLowerCase().normalize('NFD').replace(accentPattern, '');
    }

    document.addEventListener('DOMContentLoaded', () => {
      initLanguageSwitcher();
      initFilters();
      loadBooks();
    });

    function initLanguageSwitcher() {
      const select = document.getElementById('language-select');
      if (!select) return;
      select.value = state.lang;
      select.addEventListener('change', () => {
        state.lang = select.value;
        document.documentElement.lang = state.lang;
        document.documentElement.dataset.lang = state.lang;
        applyTranslations();
        renderBooks();
      });
      applyTranslations();
    }

    function applyTranslations() {
      const dict = translations[state.lang] || translations.ru;
      document.title = dict.pageTitle;
      document.querySelectorAll('[data-i18n]').forEach((node) => {
        const key = node.dataset.i18n;
        if (dict[key]) {
          node.textContent = dict[key];
        }
      });
      document.querySelectorAll('[data-i18n-placeholder]').forEach((input) => {
        const key = input.dataset.i18nPlaceholder;
        if (dict[key]) {
          input.placeholder = dict[key];
        }
      });
    }

    function initFilters() {
      const form = document.getElementById('filter-form');
      form?.querySelectorAll('input[data-filter]').forEach((input) => {
        input.addEventListener('input', (event) => {
          const target = event.currentTarget;
          const name = target.dataset.filter;
          state.filters[name] = normalizeText(target.value);
          renderBooks();
        });
      });
      document.getElementById('reset-filters')?.addEventListener('click', () => {
        Object.keys(state.filters).forEach((key) => (state.filters[key] = ''));
        form?.querySelectorAll('input[data-filter]').forEach((input) => {
          input.value = '';
        });
        renderBooks();
      });
    }

    async function loadBooks() {
      updateStatus('statusLoading');
      const cached = readBooksFromCache();
      if (cached) {
        state.books = cached.books;
        state.cacheChecksum = cached.checksum || '';
        renderBooks();
      }
      const loaders = [loadFromExcelSource, loadFromTsvSource];
      for (const loader of loaders) {
        try {
          const result = await loader();
          if (result && Array.isArray(result.books) && result.books.length) {
            state.books = result.books;
            renderBooks();
            persistBooks(state.books, result.cachePayload).catch(() => {});
            return;
          }
        } catch (error) {
          console.warn('Failed to load catalog from source', error);
        }
      }
      if (!state.books.length) {
        updateStatus('statusEmpty');
        const grid = document.getElementById('book-grid');
        if (grid) {
          grid.innerHTML = `<div class="empty-state">${translations[state.lang].statusEmpty}</div>`;
        }
      }
    }

    async function loadFromExcelSource() {
      if (typeof XLSX === 'undefined') {
        throw new Error('XLSX library is not available');
      }
      let lastError = null;
      for (const source of excelSources) {
        try {
          const response = await fetch(source, { cache: 'no-store' });
          if (!response.ok) {
            throw new Error(`Network error while requesting ${source}`);
          }
          const buffer = await response.arrayBuffer();
          const workbook = XLSX.read(buffer, { type: 'array' });
          const sheet = workbook.Sheets[workbook.SheetNames[0]];
          const rawRows = XLSX.utils.sheet_to_json(sheet, { header: 1, defval: '', blankrows: true });
          excelImageMap = await extractExcelImages(buffer).catch(() => new Map());
          const rows = convertSheetRowsToObjects(rawRows);
          const books = rows
            .map((row) => normalizeRow(row))
            .filter((book) => book.title || book.author);
          return { books, cachePayload: buffer };
        } catch (error) {
          lastError = error;
          console.warn(`Failed to load ${source}`, error);
        }
      }
      throw lastError || new Error('Excel sources are not available');
    }

    async function loadFromTsvSource() {
      const response = await fetch('books.html', { cache: 'no-store' });
      if (!response.ok) {
        throw new Error('Network error while requesting books.html');
      }
      const text = await response.text();
      const rows = parseTsv(text);
      const books = rows
        .map((row) => normalizeRow(row))
        .filter((book) => book.title || book.author);
      return { books, cachePayload: text };
    }

    function readBooksFromCache() {
      let storage;
      try {
        storage = window.localStorage;
      } catch (error) {
        console.warn('Local storage is not available', error);
        return null;
      }
      if (!storage) {
        return null;
      }
      try {
        const raw = storage.getItem(BOOK_CACHE_KEY);
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        if (parsed.version !== BOOK_CACHE_VERSION) return null;
        if (!Array.isArray(parsed.books) || !parsed.books.length) return null;
        if (typeof parsed.timestamp !== 'number' || Date.now() - parsed.timestamp > BOOK_CACHE_TTL) {
          return null;
        }
        return parsed;
      } catch (error) {
        console.warn('Failed to read cached books', error);
        return null;
      }
    }

    async function persistBooks(books, payload) {
      let storage;
      try {
        storage = window.localStorage;
      } catch (error) {
        console.warn('Local storage is not available', error);
        return;
      }
      if (!storage) {
        return;
      }
      try {
        const checksum = await hashPayload(payload);
        const cacheRecord = {
          version: BOOK_CACHE_VERSION,
          timestamp: Date.now(),
          checksum,
          books: books.map((book) => sanitizeBookForCache(book))
        };
        storage.setItem(BOOK_CACHE_KEY, JSON.stringify(cacheRecord));
        state.cacheChecksum = checksum;
      } catch (error) {
        console.warn('Failed to persist book cache', error);
      }
    }

    async function hashPayload(payload) {
      if (!window.crypto?.subtle) {
        return '';
      }
      let data;
      if (typeof payload === 'string') {
        data = new TextEncoder().encode(payload);
      } else if (payload instanceof ArrayBuffer) {
        data = new Uint8Array(payload);
      } else if (ArrayBuffer.isView(payload)) {
        data = new Uint8Array(payload.buffer);
      } else {
        return '';
      }
      const digest = await window.crypto.subtle.digest('SHA-256', data);
      return Array.from(new Uint8Array(digest))
        .map((byte) => byte.toString(16).padStart(2, '0'))
        .join('');
    }

    function sanitizeBookForCache(book) {
      if (!book || typeof book !== 'object') {
        return {};
      }
      const copy = { ...book };
      if (typeof copy.cover === 'string' && copy.cover.startsWith('data:image/')) {
        copy.cover = '';
      }
      return copy;
    }

    function parseTsv(text) {
      if (typeof text !== 'string') {
        return [];
      }
      const cleaned = text.replace(/^﻿/, '');
      const lines = cleaned.split(/\r?\n/);
      const headerIndex = lines.findIndex((line) => line.trim());
      if (headerIndex === -1) {
        return [];
      }
      const header = lines[headerIndex].split('\t').map((cell) => cell.trim());
      const rows = [];
      for (let i = headerIndex + 1; i < lines.length; i += 1) {
        const line = lines[i];
        if (!line || !line.trim()) {
          continue;
        }
        const cells = line.split('\t');
        const row = {};
        let hasValue = false;
        header.forEach((key, index) => {
          const value = (cells[index] || '').trim();
          if (value) {
            hasValue = true;
          }
          row[key] = value;
        });
        if (hasValue) {
          rows.push(row);
        }
      }
      return rows;
    }

    function convertSheetRowsToObjects(rawRows) {
      if (!Array.isArray(rawRows) || rawRows.length <= 1) {
        return [];
      }
      const width = rawRows.reduce((max, row) => Math.max(max, Array.isArray(row) ? row.length : 0), 0);
      if (width === 0) {
        return [];
      }
      const headerRow = rawRows[0];
      const normalizedHeaders = Array.from({ length: width }, (_, index) => {
        const cell = headerRow[index];
        if (typeof cell === 'string') {
          const trimmed = cell.trim();
          if (trimmed) {
            return trimmed;
          }
        }
        return '';
      });
      const result = [];
      for (let rowIndex = 1; rowIndex < rawRows.length; rowIndex += 1) {
        const row = Array.isArray(rawRows[rowIndex]) ? rawRows[rowIndex] : [];
        const record = {};
        let hasValue = false;
        for (let colIndex = 0; colIndex < width; colIndex += 1) {
          const value = row[colIndex] ?? '';
          const hasCellValue =
            typeof value === 'number'
              ? true
              : typeof value === 'string'
              ? Boolean(value.trim())
              : Boolean(value);
          if (hasCellValue) {
            hasValue = true;
          }
          const header = normalizedHeaders[colIndex];
          if (header) {
            record[header] = value;
          }
          record[`__COL_${getColumnLetter(colIndex)}`] = value;
        }
        record.__rowIndex = rowIndex;
        if (hasValue) {
          result.push(record);
        }
      }
      return result;
    }

    function getColumnLetter(index) {
      let letter = '';
      let current = Number(index);
      if (!Number.isFinite(current) || current < 0) {
        return '';
      }
      while (current >= 0) {
        letter = String.fromCharCode((current % 26) + 65) + letter;
        current = Math.floor(current / 26) - 1;
      }
      return letter;
    }

    function normalizeRow(row) {
      const getValue = (keys) => {
        for (const key of keys) {
          if (row[key] !== undefined && row[key] !== null) {
            const value = String(row[key]).trim();
            if (value) {
              return value;
            }
          }
        }
        return '';
      };
      const title = getValue(columnAliases.title);
      const author = getValue(columnAliases.author);
      const specialty = getValue(columnAliases.specialty);
      const { sanitizedLink, hasExternalLink } = normalizeLink(getValue(columnAliases.link), title, author);
      const rowIndex = typeof row.__rowIndex === 'number' ? row.__rowIndex : null;
      let coverValue = getValue(columnAliases.cover);
      if (!coverValue && rowIndex !== null) {
        coverValue = getExcelCover(rowIndex);
      }
      return {
        title,
        author,
        publisher: getValue(columnAliases.publisher),
        city: getValue(columnAliases.city),
        year: getValue(columnAliases.year),
        pages: getValue(columnAliases.pages),
        language: getValue(columnAliases.language),
        specialty,
        link: sanitizedLink,
        hasExternalLink,
        cover: resolveCoverValue(coverValue, title, author, specialty)
      };
    }

    function normalizeLink(value, title, author) {
      const trimmed = (value || '').trim();
      if (trimmed) {
        if (/^https?:\/\//i.test(trimmed)) {
          return { sanitizedLink: trimmed, hasExternalLink: true };
        }
        if (/^www\./i.test(trimmed)) {
          return { sanitizedLink: `https://${trimmed}`, hasExternalLink: true };
        }
      }
      const query = [title, author].filter(Boolean).join(' ').trim();
      const fallbackQuery = query || trimmed;
      const fallbackLink = `https://www.google.com/search?q=${encodeURIComponent(fallbackQuery || 'medical book')}`;
      return { sanitizedLink: fallbackLink, hasExternalLink: false };
    }

    function resolveCoverValue(value, title, author, specialty) {
      let source = value;
      const fallbackKey = [title, author, specialty].filter(Boolean).join(' | ');
      if (typeof source === 'string') {
        const trimmed = source.trim();
        if (!trimmed) {
          source = '';
        } else if ((trimmed.startsWith('{') || trimmed.startsWith('[')) && trimmed.length > 4) {
          try {
            const parsed = JSON.parse(trimmed);
            if (typeof parsed === 'string') {
              source = parsed;
            } else if (Array.isArray(parsed)) {
              source = parsed.find((item) => typeof item === 'string' && item.trim());
            } else if (parsed && typeof parsed.url === 'string') {
              source = parsed.url;
            }
          } catch (error) {
            console.warn('Unable to parse cover value', error);
          }
        } else {
          source = trimmed;
        }
      }
      return sanitizeUrl(source, getFallbackCover(fallbackKey));
    }

    function getExcelCover(rowIndex) {
      if (!excelImageMap || !excelImageMap.size) {
        return '';
      }
      const candidates = [rowIndex, rowIndex + 1, rowIndex - 1];
      for (const candidate of candidates) {
        if (Number.isInteger(candidate) && candidate >= 0 && excelImageMap.has(candidate)) {
          return excelImageMap.get(candidate);
        }
      }
      return '';
    }

    function sanitizeUrl(value, fallback) {
      if (!value || typeof value !== 'string') {
        return fallback;
      }
      const trimmed = value.trim();
      if (!trimmed) {
        return fallback;
      }
      if (/^(?:https?:|data:image|blob:)/i.test(trimmed)) {
        return trimmed;
      }
      if (/^(?:\.\/|\/)?[\w\-./]+\.(?:png|jpe?g|webp|gif|svg)$/i.test(trimmed)) {
        return trimmed.startsWith('./') || trimmed.startsWith('/') ? trimmed : `./${trimmed}`;
      }
      return fallback;
    }

    function getFallbackCover(key) {
      const normalized = (key || 'default').toLowerCase();
      if (fallbackCoverCache.has(normalized)) {
        return fallbackCoverCache.get(normalized);
      }
      const hash = hashString(normalized);
      const index = Math.abs(hash) % fallbackCoverImages.length;
      const url = `./${fallbackCoverImages[index]}`;
      fallbackCoverCache.set(normalized, url);
      return url;
    }

    function hashString(value) {
      let hash = 0;
      const str = value || '';
      for (let i = 0; i < str.length; i += 1) {
        hash = (hash << 5) - hash + str.charCodeAt(i);
        hash |= 0;
      }
      return hash;
    }

    async function extractExcelImages(buffer) {
      if (typeof JSZip === 'undefined' || typeof DOMParser === 'undefined') {
        return new Map();
      }
      try {
        const zip = await JSZip.loadAsync(buffer);
        const parser = new DOMParser();
        const workbookPath = 'xl/workbook.xml';
        const workbookXml = await loadZipText(zip, workbookPath);
        if (!workbookXml) {
          return new Map();
        }
        const workbookDoc = parser.parseFromString(workbookXml, 'application/xml');
        const firstSheet = workbookDoc.querySelector('sheet');
        if (!firstSheet) {
          return new Map();
        }
        const sheetRelId = firstSheet.getAttribute('r:id');
        if (!sheetRelId) {
          return new Map();
        }
        const workbookRelsXml = await loadZipText(zip, getRelationshipPath(workbookPath));
        if (!workbookRelsXml) {
          return new Map();
        }
        const workbookRelsDoc = parser.parseFromString(workbookRelsXml, 'application/xml');
        const sheetRelNode = workbookRelsDoc.querySelector(`Relationship[Id="${sheetRelId}"]`);
        const sheetTarget = sheetRelNode?.getAttribute('Target');
        if (!sheetTarget) {
          return new Map();
        }
        const sheetPath = resolveZipTarget(workbookPath, sheetTarget);
        const sheetRelsPath = getRelationshipPath(sheetPath);
        const sheetRelsXml = await loadZipText(zip, sheetRelsPath);
        if (!sheetRelsXml) {
          return new Map();
        }
        const sheetRelsDoc = parser.parseFromString(sheetRelsXml, 'application/xml');
        const drawingRelNode = sheetRelsDoc.querySelector(`Relationship[Type="${DRAWING_REL_TYPE}"]`);
        const drawingTarget = drawingRelNode?.getAttribute('Target');
        if (!drawingTarget) {
          return new Map();
        }
        const drawingPath = resolveZipTarget(sheetRelsPath, drawingTarget);
        const drawingXml = await loadZipText(zip, drawingPath);
        const drawingRelsPath = getRelationshipPath(drawingPath);
        const drawingRelsXml = await loadZipText(zip, drawingRelsPath);
        if (!drawingXml || !drawingRelsXml) {
          return new Map();
        }
        const drawingDoc = parser.parseFromString(drawingXml, 'application/xml');
        const drawingRelsDoc = parser.parseFromString(drawingRelsXml, 'application/xml');
        const relationshipMap = new Map();
        drawingRelsDoc.querySelectorAll('Relationship').forEach((node) => {
          const relId = node.getAttribute('Id');
          const relTarget = node.getAttribute('Target');
          if (relId && relTarget) {
            relationshipMap.set(relId, resolveZipTarget(drawingRelsPath, relTarget));
          }
        });
        const anchors = [
          ...drawingDoc.getElementsByTagNameNS(XDR_NS, 'oneCellAnchor'),
          ...drawingDoc.getElementsByTagNameNS(XDR_NS, 'twoCellAnchor')
        ];
        const map = new Map();
        for (const anchor of anchors) {
          const fromNode = anchor.getElementsByTagNameNS(XDR_NS, 'from')[0];
          const picNode = anchor.getElementsByTagNameNS(XDR_NS, 'pic')[0];
          if (!fromNode || !picNode) {
            continue;
          }
          const rowNode = fromNode.getElementsByTagNameNS(XDR_NS, 'row')[0];
          if (!rowNode) {
            continue;
          }
          const rowIndex = Number.parseInt(rowNode.textContent || '', 10);
          if (!Number.isFinite(rowIndex)) {
            continue;
          }
          if (map.has(rowIndex)) {
            continue;
          }
          const blip = picNode.getElementsByTagNameNS(DRAWING_NS, 'blip')[0];
          if (!blip) {
            continue;
          }
          const relId = blip.getAttributeNS(EXCEL_REL_NS, 'embed');
          if (!relId) {
            continue;
          }
          const mediaPath = relationshipMap.get(relId);
          if (!mediaPath) {
            continue;
          }
          const normalizedPath = mediaPath.replace(/^\//, '');
          const fileEntry = zip.file(normalizedPath);
          if (!fileEntry) {
            continue;
          }
          const bytes = await fileEntry.async('uint8array');
          if (!bytes || !bytes.length) {
            continue;
          }
          const mimeType = getMimeTypeFromPath(normalizedPath);
          map.set(rowIndex, `data:${mimeType};base64,${uint8ArrayToBase64(bytes)}`);
        }
        return map;
      } catch (error) {
        console.warn('Failed to extract Excel images', error);
        return new Map();
      }
    }

    async function loadZipText(zip, path) {
      if (!zip || !path) {
        return '';
      }
      const normalized = path.replace(/^\//, '');
      const fileEntry = zip.file(normalized);
      if (!fileEntry) {
        return '';
      }
      return fileEntry.async('string');
    }

    function resolveZipTarget(basePath, target) {
      if (!target) {
        return '';
      }
      if (target.startsWith('/')) {
        return target.slice(1);
      }
      const baseParts = basePath.split('/');
      baseParts.pop();
      const segments = target.split('/');
      for (const segment of segments) {
        if (!segment || segment === '.') {
          continue;
        }
        if (segment === '..') {
          if (baseParts.length) {
            baseParts.pop();
          }
        } else {
          baseParts.push(segment);
        }
      }
      return baseParts.join('/');
    }

    function getRelationshipPath(filePath) {
      if (!filePath) {
        return '';
      }
      const lastSlash = filePath.lastIndexOf('/');
      const dir = lastSlash === -1 ? '' : filePath.slice(0, lastSlash + 1);
      const fileName = lastSlash === -1 ? filePath : filePath.slice(lastSlash + 1);
      return `${dir}_rels/${fileName}.rels`;
    }

    function getMimeTypeFromPath(path) {
      if (!path) {
        return 'image/png';
      }
      const extension = path.split('.').pop()?.toLowerCase();
      switch (extension) {
        case 'jpg':
        case 'jpeg':
          return 'image/jpeg';
        case 'gif':
          return 'image/gif';
        case 'webp':
          return 'image/webp';
        case 'png':
        default:
          return 'image/png';
      }
    }

    function uint8ArrayToBase64(bytes) {
      if (!bytes || !bytes.length) {
        return '';
      }
      let binary = '';
      const chunkSize = 0x8000;
      for (let index = 0; index < bytes.length; index += chunkSize) {
        const chunk = bytes.subarray(index, index + chunkSize);
        binary += String.fromCharCode.apply(null, Array.from(chunk));
      }
      return btoa(binary);
    }

    function escapeHtml(value) {
      return String(value || '')
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    function renderBooks() {
      const grid = document.getElementById('book-grid');
      if (!grid) return;
      const dict = translations[state.lang] || translations.ru;
      const books = getFilteredBooks();
      if (!state.books.length) {
        grid.innerHTML = `<div class="empty-state">${dict.statusLoading}</div>`;
        updateStatus('statusLoading');
        return;
      }
      grid.innerHTML = '';
      if (!books.length) {
        grid.innerHTML = `<div class="empty-state">${dict.statusEmpty}</div>`;
      } else {
        const fragment = document.createDocumentFragment();
        books.forEach((book) => {
          fragment.appendChild(createBookCard(book, dict));
        });
        grid.appendChild(fragment);
      }
      updateCountStatus(books.length, state.books.length);
      hydrateCoverImages();
    }

    function getFilteredBooks() {
      return state.books.filter((book) => {
        const normalizedTitle = normalizeText(book.title);
        if (state.filters.title && !normalizedTitle.includes(state.filters.title)) {
          return false;
        }
        const normalizedAuthor = normalizeText(book.author);
        if (state.filters.author && !normalizedAuthor.includes(state.filters.author)) {
          return false;
        }
        const normalizedYear = normalizeText(book.year);
        if (state.filters.year && !normalizedYear.includes(state.filters.year)) {
          return false;
        }
        const normalizedSpecialty = normalizeText(book.specialty);
        if (state.filters.specialty && !normalizedSpecialty.includes(state.filters.specialty)) {
          return false;
        }
        const normalizedLanguage = normalizeText(book.language);
        if (state.filters.language && !normalizedLanguage.includes(state.filters.language)) {
          return false;
        }
        return true;
      });
    }

    function createBookCard(book, dict) {
      const article = document.createElement('article');
      article.className = 'book-card';
      const specialty = book.specialty || dict.cardSpecialtyEmpty;
      const language = book.language || dict.cardLanguageEmpty;
      const targetLink = book.link || `https://www.google.com/search?q=${encodeURIComponent((book.title || '') + ' ' + (book.author || ''))}`;
      const isExternal = book.hasExternalLink === true && Boolean(book.link);
      const safeTitle = escapeHtml(book.title || dict.cardSpecialtyEmpty);
      const safeAuthor = escapeHtml(book.author || '—');
      const safeLanguage = escapeHtml(language);
      const safePublisher = escapeHtml(book.publisher || '—');
      const safeCity = escapeHtml(book.city || '—');
      const safePages = escapeHtml(book.pages || '—');
      const safeYear = escapeHtml(book.year || dict.cardYear);
      const safeSpecialty = escapeHtml(specialty);
      const coverSource = escapeHtml(book.cover || getFallbackCover(book.title || book.author || specialty || 'default'));
      const coverQuery = [book.title, book.author, book.specialty]
        .filter((value) => Boolean(value && value.trim()))
        .join(' ')
        .trim();
      const coverAlt = escapeHtml(book.title || dict.cardCoverAlt);
      article.innerHTML = `
        <div class="book-card__media">
          <img src="${coverSource}" alt="${coverAlt}" loading="lazy" decoding="async">
        </div>
        <div class="book-card__top">
          <span class="book-card__chip">${safeSpecialty}</span>
          <span class="book-card__chip">${safeYear}</span>
        </div>
        <div>
          <h3 class="book-card__title">${safeTitle}</h3>
          <p class="book-card__author">${dict.cardAuthor}: ${safeAuthor}</p>
        </div>
        <div class="book-card__details">
          <div>
            <span class="book-card__label">${dict.cardLanguage}</span>
            <strong>${safeLanguage}</strong>
          </div>
          <div>
            <span class="book-card__label">${dict.cardPublisher}</span>
            <strong>${safePublisher}</strong>
          </div>
          <div>
            <span class="book-card__label">${dict.cardCity}</span>
            <strong>${safeCity}</strong>
          </div>
          <div>
            <span class="book-card__label">${dict.cardPages}</span>
            <strong>${safePages}</strong>
          </div>
        </div>
      `;
      const actions = document.createElement('div');
      actions.className = 'book-card__actions';
      const button = document.createElement('a');
      button.className = 'book-card__link';
      button.textContent = isExternal ? dict.cardOpen : dict.cardSearch;
      button.href = targetLink;
      button.target = '_blank';
      button.rel = 'noopener';
      actions.appendChild(button);
      article.appendChild(actions);
      const image = article.querySelector('.book-card__media img');
      if (image && coverQuery) {
        image.dataset.coverQuery = coverQuery;
        image.dataset.coverTitle = book.title || '';
        image.dataset.coverAuthor = book.author || '';
      }
      return article;
    }

    function hydrateCoverImages() {
      const images = document.querySelectorAll('.book-card__media img[data-cover-query]');
      images.forEach((image) => {
        if (!image || image.dataset.coverHydrated === 'true') {
          return;
        }
        if (coverObserver) {
          coverObserver.observe(image);
        } else {
          upgradeCoverImage(image);
        }
      });
    }

    async function upgradeCoverImage(image) {
      if (!image || image.dataset.coverHydrated === 'true') {
        return;
      }
      const rawQuery = image.dataset.coverQuery || `${image.dataset.coverTitle || ''} ${image.dataset.coverAuthor || ''}`;
      const cacheKey = normalizeText(rawQuery);
      if (!cacheKey) {
        return;
      }
      const cached = getCachedCover(cacheKey);
      if (cached) {
        image.src = cached;
        image.dataset.coverHydrated = 'true';
        return;
      }
      if (!coverFetchPromises.has(cacheKey)) {
        coverFetchPromises.set(cacheKey, fetchRemoteCover(image.dataset.coverTitle, image.dataset.coverAuthor));
      }
      try {
        const remoteUrl = await coverFetchPromises.get(cacheKey);
        if (remoteUrl) {
          image.src = remoteUrl;
          image.dataset.coverHydrated = 'true';
          cacheRemoteCover(cacheKey, remoteUrl);
        }
      } catch (error) {
        console.warn('Unable to load remote cover', error);
      } finally {
        coverFetchPromises.delete(cacheKey);
      }
    }

    function ensureRemoteCoverCache() {
      if (remoteCoverCacheLoaded) {
        return;
      }
      remoteCoverCacheLoaded = true;
      try {
        const raw = localStorage.getItem(REMOTE_COVER_CACHE_KEY);
        if (!raw) {
          return;
        }
        const parsed = JSON.parse(raw);
        if (parsed?.version !== REMOTE_COVER_CACHE_VERSION || !Array.isArray(parsed?.entries)) {
          return;
        }
        parsed.entries.forEach(([key, value]) => {
          if (typeof key === 'string' && typeof value === 'string') {
            remoteCoverCache.set(key, value);
          }
        });
      } catch (error) {
        console.warn('Unable to parse cover cache', error);
      }
    }

    function getCachedCover(key) {
      if (!key) {
        return '';
      }
      ensureRemoteCoverCache();
      return remoteCoverCache.get(key) || '';
    }

    const scheduleCoverCachePersist = (() => {
      let pending = false;
      return () => {
        if (pending) {
          return;
        }
        pending = true;
        idleCallback(() => {
          pending = false;
          persistCoverCache();
        });
      };
    })();

    function cacheRemoteCover(key, url) {
      if (!key || !url) {
        return;
      }
      ensureRemoteCoverCache();
      remoteCoverCache.set(key, url);
      scheduleCoverCachePersist();
    }

    function persistCoverCache() {
      if (!remoteCoverCacheLoaded) {
        return;
      }
      const entries = Array.from(remoteCoverCache.entries()).slice(-200);
      try {
        localStorage.setItem(
          REMOTE_COVER_CACHE_KEY,
          JSON.stringify({ version: REMOTE_COVER_CACHE_VERSION, entries })
        );
      } catch (error) {
        console.warn('Unable to persist cover cache', error);
      }
    }

    async function fetchRemoteCover(title, author) {
      const normalizedTitle = (title || '').trim();
      const normalizedAuthor = (author || '').trim();
      if (!normalizedTitle && !normalizedAuthor) {
        return '';
      }
      const params = new URLSearchParams({ limit: '1' });
      if (normalizedTitle) {
        params.set('title', title);
      }
      if (normalizedAuthor) {
        params.set('author', author);
      }
      const controller = new AbortController();
      const timeoutId = window.setTimeout(() => controller.abort(), 4500);
      try {
        const response = await fetch(`https://openlibrary.org/search.json?${params.toString()}`, {
          signal: controller.signal
        });
        if (!response.ok) {
          throw new Error('Network error while fetching cover');
        }
        const payload = await response.json();
        const doc = payload?.docs?.[0];
        if (doc?.cover_i) {
          return `https://covers.openlibrary.org/b/id/${doc.cover_i}-L.jpg`;
        }
        if (Array.isArray(doc?.isbn) && doc.isbn.length) {
          return `https://covers.openlibrary.org/b/isbn/${encodeURIComponent(doc.isbn[0])}-L.jpg`;
        }
        return '';
      } finally {
        window.clearTimeout(timeoutId);
      }
    }

    function updateStatus(key) {
      const pill = document.getElementById('status-pill');
      if (!pill) return;
      const dict = translations[state.lang] || translations.ru;
      const template = dict[key];
      pill.textContent = template || '';
    }

    function updateCountStatus(count, total) {
      const pill = document.getElementById('status-pill');
      if (!pill) return;
      const dict = translations[state.lang] || translations.ru;
      const key = count === total ? 'statusTotal' : 'statusFiltered';
      const template = dict[key] || '';
      pill.textContent = template.replace('{count}', count).replace('{total}', total);
    }
  </script>
  <script src="pwa.js"></script>
</body>
</html>
