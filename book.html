<!DOCTYPE html>
<html lang="ru" data-lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Медицинская электронная библиотека — книги</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      color-scheme: light;
      --bg: #f5f6fb;
      --card-bg: #ffffff;
      --primary: #0b6efd;
      --primary-dark: #084298;
      --text: #1f2a37;
      --muted: #5f6b7c;
      --border: #d9e0ec;
      --shadow: 0 12px 32px rgba(15, 23, 42, 0.08);
      --chip-bg: #e7f1ff;
      --chip-text: #1c4ed8;
      font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      background: var(--bg);
      color: var(--text);
      line-height: 1.6;
    }

    a {
      color: var(--primary);
      text-decoration: none;
    }

    .site-header {
      background: var(--card-bg);
      padding: 1.5rem clamp(1rem, 4vw, 4rem);
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      align-items: center;
      gap: 1rem;
      box-shadow: 0 1px 0 rgba(15, 23, 42, 0.08);
      position: sticky;
      top: 0;
      z-index: 10;
    }

    .logo-area {
      display: flex;
      flex-direction: column;
      gap: 0.2rem;
    }

    .logo-area__eyebrow {
      font-size: 0.9rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .logo-area__title {
      font-size: clamp(1.5rem, 2vw, 2rem);
      margin: 0;
    }

    .language-switcher {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-weight: 500;
    }

    select {
      border-radius: 999px;
      border: 1px solid var(--border);
      padding: 0.4rem 1.2rem;
      font-size: 1rem;
      font-family: inherit;
      background: #fff;
      color: var(--text);
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }

    select:focus-visible, input:focus-visible {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(11, 110, 253, 0.15);
    }

    nav {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      padding: 0.75rem clamp(1rem, 4vw, 4rem);
      background: transparent;
    }

    nav a {
      font-weight: 500;
      color: var(--muted);
      padding: 0.25rem 0.5rem;
      border-radius: 999px;
      transition: color 0.2s ease, background 0.2s ease;
    }

    nav a:hover,
    nav a:focus-visible {
      color: var(--primary);
      background: rgba(11, 110, 253, 0.08);
    }

    main {
      padding: 2rem clamp(1rem, 4vw, 4rem) 4rem;
      display: flex;
      flex-direction: column;
      gap: 2rem;
    }

    .filter-panel {
      background: var(--card-bg);
      border-radius: 24px;
      padding: clamp(1.5rem, 3vw, 2.5rem);
      box-shadow: var(--shadow);
    }

    .filter-panel__head {
      margin-bottom: 1.5rem;
    }

    .filter-panel__title {
      margin: 0 0 0.3rem;
      font-size: clamp(1.5rem, 2vw, 2rem);
    }

    .filter-panel__subtitle {
      margin: 0;
      color: var(--muted);
    }

    .filter-form {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 1rem;
      align-items: end;
    }

    .filter-field {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
      font-weight: 500;
      color: var(--muted);
    }

    .filter-field input {
      border-radius: 14px;
      border: 1px solid var(--border);
      padding: 0.85rem 1rem;
      font-size: 1rem;
      font-family: inherit;
      transition: border-color 0.2s ease, box-shadow 0.2s ease, transform 0.2s ease;
      background: #fdfdff;
    }

    .filter-field input:hover {
      transform: translateY(-1px);
      border-color: var(--primary);
    }

    .filter-actions {
      display: flex;
      gap: 0.75rem;
      flex-wrap: wrap;
      margin-top: 0.5rem;
    }

    .button {
      border: none;
      border-radius: 14px;
      padding: 0.85rem 1.5rem;
      font-size: 1rem;
      font-weight: 600;
      font-family: inherit;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
    }

    .button--primary {
      background: var(--primary);
      color: #fff;
      box-shadow: 0 12px 20px rgba(11, 110, 253, 0.25);
    }

    .button--primary:hover {
      transform: translateY(-2px);
      background: var(--primary-dark);
    }

    .button--ghost {
      background: rgba(15, 23, 42, 0.06);
      color: var(--text);
    }

    .status-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 1rem;
      flex-wrap: wrap;
    }

    .status-pill {
      background: var(--card-bg);
      border-radius: 999px;
      padding: 0.35rem 0.95rem;
      color: var(--muted);
      font-weight: 500;
      box-shadow: 0 8px 18px rgba(15, 23, 42, 0.08);
    }

    .book-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 1.5rem;
    }

    .book-card {
      background: var(--card-bg);
      border-radius: 24px;
      padding: 1.5rem;
      box-shadow: var(--shadow);
      display: flex;
      flex-direction: column;
      gap: 1rem;
      transition: transform 0.25s ease, box-shadow 0.25s ease;
      min-height: 280px;
    }

    .book-card__media {
      width: 100%;
      aspect-ratio: 3 / 4;
      border-radius: 18px;
      overflow: hidden;
      position: relative;
      background: linear-gradient(135deg, rgba(11, 110, 253, 0.15), rgba(15, 23, 42, 0.15));
      box-shadow: inset 0 0 0 1px rgba(15, 23, 42, 0.04);
    }

    .book-card__media img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    .book-card:hover {
      transform: translateY(-6px) scale(1.01);
      box-shadow: 0 20px 35px rgba(15, 23, 42, 0.15);
    }

    .book-card__top {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .book-card__chip {
      background: var(--chip-bg);
      color: var(--chip-text);
      padding: 0.2rem 0.85rem;
      border-radius: 999px;
      font-size: 0.85rem;
      font-weight: 600;
    }

    .book-card__title {
      margin: 0;
      font-size: 1.15rem;
      line-height: 1.4;
    }

    .book-card__author {
      margin: 0;
      color: var(--muted);
      font-size: 0.95rem;
    }

    .book-card__details {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 0.65rem 1rem;
      font-size: 0.9rem;
    }

    .book-card__label {
      color: var(--muted);
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      display: block;
    }

    .book-card__actions {
      margin-top: auto;
      display: flex;
      gap: 0.75rem;
      flex-wrap: wrap;
    }

    .book-card__link {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.4rem;
      border-radius: 14px;
      padding: 0.7rem 1.2rem;
      font-weight: 600;
      background: var(--primary);
      color: #fff;
      transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
      flex: 1;
      min-width: 160px;
    }

    .book-card__link:hover {
      transform: translateY(-2px);
      background: var(--primary-dark);
      box-shadow: 0 15px 20px rgba(11, 110, 253, 0.2);
    }

    .book-card__link[aria-disabled="true"] {
      cursor: not-allowed;
      background: rgba(15, 23, 42, 0.12);
      box-shadow: none;
    }

    .empty-state {
      grid-column: 1 / -1;
      background: rgba(11, 110, 253, 0.08);
      color: var(--primary-dark);
      padding: 2rem;
      border-radius: 24px;
      text-align: center;
      font-weight: 600;
    }

    footer {
      background: #0f172a;
      color: rgba(255, 255, 255, 0.8);
      padding: 2.5rem clamp(1rem, 4vw, 4rem);
      margin-top: 3rem;
    }

    .footer-content {
      display: flex;
      flex-wrap: wrap;
      gap: 2rem;
      justify-content: space-between;
    }

    .footer-content a {
      color: #fff;
      font-weight: 600;
    }

    @media (max-width: 720px) {
      .book-card__details {
        grid-template-columns: 1fr;
      }

      .site-header {
        position: static;
      }
    }
  </style>
</head>
<body>
  <header class="site-header">
    <div class="logo-area">
      <span class="logo-area__eyebrow" data-i18n="tagline">Медицинская электронная библиотека</span>
      <h1 class="logo-area__title" data-i18n="heroTitle">Каталог медицинских книг</h1>
    </div>
    <div class="language-switcher">
      <label for="language-select" data-i18n="languageLabel">Язык интерфейса:</label>
      <select id="language-select" aria-label="Select interface language">
        <option value="tm">Türkmençe</option>
        <option value="ru" selected>Русский</option>
        <option value="en">English</option>
      </select>
    </div>
  </header>
  <nav aria-label="Primary">
    <a href="index.html" data-i18n="navHome">Главная</a>
    <a href="BookCategory.html" data-i18n="navCategories">Категории</a>
    <a href="book.html" aria-current="page" data-i18n="navBooks">Каталог книг</a>
    <a href="https://sites.google.com/view/lukmanylyksanlykitaphanasy/ba%C5%9F-sahypa" target="_blank" rel="noopener" data-i18n="navAltSite">Другой сайт библиотеки</a>
  </nav>
  <main>
    <section class="filter-panel" aria-labelledby="filter-title">
      <div class="filter-panel__head">
        <p class="logo-area__eyebrow" data-i18n="filterEyebrow">Фильтр книг</p>
        <h2 id="filter-title" class="filter-panel__title" data-i18n="filterTitle">Найдите нужную литературу</h2>
        <p class="filter-panel__subtitle" data-i18n="filterSubtitle">Используйте отдельные поля ниже, чтобы быстро отфильтровать книги по названию, автору, году, разделу и языку.</p>
      </div>
      <div class="filter-form" id="filter-form">
        <label class="filter-field">
          <span data-i18n="labelTitle">Название книги</span>
          <input type="text" data-filter="title" data-i18n-placeholder="placeholderTitle" placeholder="Например: нейрохирургия" autocomplete="off">
        </label>
        <label class="filter-field">
          <span data-i18n="labelAuthor">Автор</span>
          <input type="text" data-filter="author" data-i18n-placeholder="placeholderAuthor" placeholder="Например: Apuzzo" autocomplete="off">
        </label>
        <label class="filter-field">
          <span data-i18n="labelYear">Год издания</span>
          <input type="text" inputmode="numeric" data-filter="year" data-i18n-placeholder="placeholderYear" placeholder="Например: 2018" autocomplete="off">
        </label>
        <label class="filter-field">
          <span data-i18n="labelSpecialty">Специальность / раздел</span>
          <input type="text" data-filter="specialty" data-i18n-placeholder="placeholderSpecialty" placeholder="Например: нейрохирургия" autocomplete="off">
        </label>
        <label class="filter-field">
          <span data-i18n="labelLanguage">Язык</span>
          <input type="text" data-filter="language" data-i18n-placeholder="placeholderLanguage" placeholder="Например: EN" autocomplete="off">
        </label>
      </div>
      <div class="filter-actions">
        <button class="button button--primary" type="button" id="reset-filters" data-i18n="reset">Сбросить фильтры</button>
      </div>
    </section>
    <section class="status-bar">
      <span class="status-pill" id="status-pill">—</span>
    </section>
    <section id="book-grid" class="book-grid" aria-live="polite"></section>
  </main>
  <footer>
    <div class="footer-content">
      <div>
        <strong data-i18n="contactTitle">Контакты</strong>
        <p><span data-i18n="contactPhone">Телефон:</span> <a href="tel:+99362234094">+993 62 23 40 94</a></p>
        <p><span data-i18n="contactEmail">Email:</span> <a href="mailto:tdlipf@gmail.com">tdlipf@gmail.com</a></p>
      </div>
      <div>
        <strong data-i18n="footerNavigation">Навигация</strong>
        <p><a href="index.html" data-i18n="navHome">Главная</a></p>
        <p><a href="BookCategory.html" data-i18n="navCategories">Категории</a></p>
      </div>
      <div>
        <strong data-i18n="footerRights">© 2025 Медицинская электронная библиотека</strong>
        <p data-i18n="footerText">Все права защищены. Проект создан для удобного доступа к медицинской литературе.</p>
      </div>
    </div>
  </footer>
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.19.3/dist/xlsx.full.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script>
    const translations = {
      ru: {
        pageTitle: 'Медицинская электронная библиотека — книги',
        tagline: 'Медицинская электронная библиотека',
        heroTitle: 'Каталог медицинских книг',
        languageLabel: 'Язык интерфейса:',
        navHome: 'Главная',
        navCategories: 'Категории',
        navBooks: 'Каталог книг',
        navAltSite: 'Другой сайт библиотеки',
        filterEyebrow: 'Фильтр книг',
        filterTitle: 'Найдите нужную литературу',
        filterSubtitle: 'Используйте отдельные поля ниже, чтобы быстро отфильтровать книги по названию, автору, году, разделу и языку.',
        labelTitle: 'Название книги',
        labelAuthor: 'Автор',
        labelYear: 'Год издания',
        labelSpecialty: 'Специальность / раздел',
        labelLanguage: 'Язык',
        placeholderTitle: 'Например: нейрохирургия',
        placeholderAuthor: 'Например: Apuzzo',
        placeholderYear: 'Например: 2018',
        placeholderSpecialty: 'Например: радиология',
        placeholderLanguage: 'Например: EN',
        reset: 'Сбросить фильтры',
        statusLoading: 'Загружаем каталог...',
        statusEmpty: 'Ничего не найдено',
        statusTotal: 'Всего книг: {count}',
        statusFiltered: 'Найдено {count} из {total}',
        cardSpecialty: 'Раздел',
        cardYear: 'Год',
        cardLanguage: 'Язык',
        cardAuthor: 'Автор',
        cardCity: 'Город',
        cardPublisher: 'Издательство',
        cardPages: 'Страниц',
        cardOpen: 'Открыть файл',
        cardSearch: 'Найти книгу',
        cardCoverAlt: 'Обложка книги',
        cardSpecialtyEmpty: 'Не указано',
        cardLanguageEmpty: '—',
        contactTitle: 'Контакты',
        contactPhone: 'Телефон:',
        contactEmail: 'Email:',
        footerNavigation: 'Навигация',
        footerRights: '© 2025 Медицинская электронная библиотека',
        footerText: 'Все права защищены. Проект создан для удобного доступа к медицинской литературе.'
      },
      en: {
        pageTitle: 'Medical e-Library — books',
        tagline: 'Medical digital library',
        heroTitle: 'Medical book catalogue',
        languageLabel: 'Interface language:',
        navHome: 'Home',
        navCategories: 'Book categories',
        navBooks: 'Book list',
        navAltSite: 'Alternative library site',
        filterEyebrow: 'Book filters',
        filterTitle: 'Find the right resource',
        filterSubtitle: 'Use the dedicated fields below to filter books by title, author, year, specialty and language in real time.',
        labelTitle: 'Book title',
        labelAuthor: 'Author',
        labelYear: 'Year',
        labelSpecialty: 'Specialty / section',
        labelLanguage: 'Language',
        placeholderTitle: 'e.g. neurosurgery',
        placeholderAuthor: 'e.g. Apuzzo',
        placeholderYear: 'e.g. 2018',
        placeholderSpecialty: 'e.g. radiology',
        placeholderLanguage: 'e.g. EN',
        reset: 'Reset filters',
        statusLoading: 'Loading catalogue...',
        statusEmpty: 'No books match your filters',
        statusTotal: 'Total books: {count}',
        statusFiltered: 'Showing {count} of {total}',
        cardSpecialty: 'Specialty',
        cardYear: 'Year',
        cardLanguage: 'Language',
        cardAuthor: 'Author',
        cardCity: 'City',
        cardPublisher: 'Publisher',
        cardPages: 'Pages',
        cardOpen: 'Open file',
        cardSearch: 'Search online',
        cardCoverAlt: 'Book cover',
        cardSpecialtyEmpty: 'Not specified',
        cardLanguageEmpty: '—',
        contactTitle: 'Contacts',
        contactPhone: 'Phone:',
        contactEmail: 'Email:',
        footerNavigation: 'Navigation',
        footerRights: '© 2025 Medical e-Library',
        footerText: 'All rights reserved. The project was created to provide convenient access to medical literature.'
      },
      tm: {
        pageTitle: 'Lukmançylyk elektron kitaphanasy — kitaplar',
        tagline: 'Lukmançylyk elektron kitaphanasy',
        heroTitle: 'Lukmançylyk kitaplary kataloogy',
        languageLabel: 'Interfeýsiň dili:',
        navHome: 'Baş sahypa',
        navCategories: 'Kategoriýalar',
        navBooks: 'Kitap katalogy',
        navAltSite: 'Kitaphananyň beýleki sahypasy',
        filterEyebrow: 'Kitap süzgüçleri',
        filterTitle: 'Gerek kitaby tapyň',
        filterSubtitle: 'Aşakdaky meýdançalar arkaly kitabyny ady, awtory, ýyly, ugry we dili boýunça dessine saýlap bilersiňiz.',
        labelTitle: 'Kitabyň ady',
        labelAuthor: 'Awtor',
        labelYear: 'Çykan ýyly',
        labelSpecialty: 'Ugry / bölüm',
        labelLanguage: 'Dil',
        placeholderTitle: 'Mysal üçin: neýrohirurgiýa',
        placeholderAuthor: 'Mysal üçin: Apuzzo',
        placeholderYear: 'Mysal üçin: 2018',
        placeholderSpecialty: 'Mysal üçin: radiologiýa',
        placeholderLanguage: 'Mysal üçin: TM',
        reset: 'Süzgüçleri arassala',
        statusLoading: 'Katalog ýüklenýär...',
        statusEmpty: 'Talaplara laýyk kitap tapylmady',
        statusTotal: 'Jemi kitap: {count}',
        statusFiltered: '{total} kitabyň {count}-si görkezildi',
        cardSpecialty: 'Ugry',
        cardYear: 'Ýyl',
        cardLanguage: 'Dil',
        cardAuthor: 'Awtor',
        cardCity: 'Şäher',
        cardPublisher: 'Neşirçi',
        cardPages: 'Sahypa',
        cardOpen: 'Faýly aç',
        cardSearch: 'Internetden tap',
        cardCoverAlt: 'Kitabyň suraty',
        cardSpecialtyEmpty: 'Gösterilmedik',
        cardLanguageEmpty: '—',
        contactTitle: 'Habarlaşmak üçin',
        contactPhone: 'Telefon:',
        contactEmail: 'Email:',
        footerNavigation: 'Navigasiýa',
        footerRights: '© 2025 Lukmançylyk elektron kitaphanasy',
        footerText: 'Ähli hukuklar goralan. Taslama lukmançylyk edebiýatyna amatly elýeterlik üçin döredildi.'
      }
    };

    const columnAliases = {
      title: ['Название книги', 'Book Name', 'Book Title', 'Kitaplar', 'Kitabyň ady', 'Name'],
      author: ['Имя автора', 'Authors Name', 'Author', 'Awtoryň ady'],
      publisher: ['Издатель', 'Publisher', 'Neşirçi'],
      city: ['Город публикации', 'Publication City', 'City', 'Şäher'],
      year: ['Год публикации', 'Publication Year', 'Год', 'Year', 'Ýyl'],
      pages: ['Количество страниц', 'Page Count', 'Pages', 'Sahypalar'],
      language: ['Язык книги', 'Book Language', 'Dil', 'Language'],
      specialty: ['Специальность', 'Специальность / раздел', 'Раздел', 'Категория', 'Category', 'Specialty', 'Bölüm', 'Ugry'],
      link: ['Ссылка', 'Link', 'URL', 'Download', 'Файл', 'File'],
      cover: ['Обложка', 'Изображение', 'Фото', 'Cover', 'Image', 'Book image', 'H', '__COL_H']
    };

    const BOOK_CACHE_KEY = 'medlibrary.bookCache';
    const BOOK_CACHE_VERSION = '2.0.0';
    const BOOK_CACHE_TTL = 1000 * 60 * 60 * 12; // 12 hours
    const excelSources = ['Book.xlsx'];
    const fallbackCoverImages = ['1.webp', '2.webp', '3.webp', '4.webp', '5.webp', '6.webp', '1.png', '2.png', '3.png', '4.png', '5.png', '6.png'];
    const fallbackCoverCache = new Map();
    const COVER_COLUMN_INDEX = 7;
    const DEFAULT_WORKSHEET_PATH = 'xl/worksheets/sheet1.xml';

    const state = {
      lang: document.documentElement.lang || 'ru',
      books: [],
      cacheChecksum: '',
      coverUrlRegistry: [],
      filters: {
        title: '',
        author: '',
        year: '',
        specialty: '',
        language: ''
      }
    };

    document.addEventListener('DOMContentLoaded', () => {
      initLanguageSwitcher();
      initFilters();
      loadBooks();
    });

    window.addEventListener('beforeunload', cleanupCoverUrls);

    function initLanguageSwitcher() {
      const select = document.getElementById('language-select');
      if (!select) return;
      select.value = state.lang;
      select.addEventListener('change', () => {
        state.lang = select.value;
        document.documentElement.lang = state.lang;
        document.documentElement.dataset.lang = state.lang;
        applyTranslations();
        renderBooks();
      });
      applyTranslations();
    }

    function applyTranslations() {
      const dict = translations[state.lang] || translations.ru;
      document.title = dict.pageTitle;
      document.querySelectorAll('[data-i18n]').forEach((node) => {
        const key = node.dataset.i18n;
        if (dict[key]) {
          node.textContent = dict[key];
        }
      });
      document.querySelectorAll('[data-i18n-placeholder]').forEach((input) => {
        const key = input.dataset.i18nPlaceholder;
        if (dict[key]) {
          input.placeholder = dict[key];
        }
      });
    }

    function initFilters() {
      const form = document.getElementById('filter-form');
      form?.querySelectorAll('input[data-filter]').forEach((input) => {
        input.addEventListener('input', (event) => {
          const target = event.currentTarget;
          const name = target.dataset.filter;
          state.filters[name] = target.value.trim().toLowerCase();
          renderBooks();
        });
      });
      document.getElementById('reset-filters')?.addEventListener('click', () => {
        Object.keys(state.filters).forEach((key) => (state.filters[key] = ''));
        form?.querySelectorAll('input[data-filter]').forEach((input) => {
          input.value = '';
        });
        renderBooks();
      });
    }

    async function loadBooks() {
      updateStatus('statusLoading');
      const cached = readBooksFromCache();
      if (cached) {
        state.books = cached.books;
        state.cacheChecksum = cached.checksum || '';
        renderBooks();
      }
      const loaders = [loadFromExcelSource, loadFromTsvSource];
      for (const loader of loaders) {
        try {
          const result = await loader();
          if (result && Array.isArray(result.books) && result.books.length) {
            cleanupCoverUrls();
            state.coverUrlRegistry = result.coverUrls || [];
            state.books = result.books;
            renderBooks();
            persistBooks(state.books, result.cachePayload).catch(() => {});
            return;
          }
        } catch (error) {
          console.warn('Failed to load catalog from source', error);
        }
      }
      if (!state.books.length) {
        updateStatus('statusEmpty');
        const grid = document.getElementById('book-grid');
        if (grid) {
          grid.innerHTML = `<div class="empty-state">${translations[state.lang].statusEmpty}</div>`;
        }
      }
    }

    async function loadFromExcelSource() {
      if (typeof XLSX === 'undefined') {
        throw new Error('XLSX library is not available');
      }
      let lastError = null;
      for (const source of excelSources) {
        try {
          const response = await fetch(source, { cache: 'no-store' });
          if (!response.ok) {
            throw new Error(`Network error while requesting ${source}`);
          }
          const buffer = await response.arrayBuffer();
          const workbook = XLSX.read(buffer, { type: 'array' });
          const sheetName = workbook.SheetNames[0];
          const sheet = workbook.Sheets[sheetName];
          if (!sheet) {
            continue;
          }
          const zip = await loadWorkbookArchive(buffer);
          const worksheetPath = await resolveWorksheetPath(zip);
          const coverExtraction = await extractEmbeddedCovers(zip, worksheetPath);
          const rows = convertSheetRowsToObjects(sheet);
          const books = rows
            .map((row) => {
              const embeddedCover = getEmbeddedCoverForRow(row.__rowNumber, coverExtraction.map);
              return normalizeRow(row, embeddedCover);
            })
            .filter((book) => book.title || book.author || book.specialty);
          if (books.length) {
            return { books, cachePayload: buffer, coverUrls: coverExtraction.urls };
          }
          revokeObjectUrls(coverExtraction.urls);
        } catch (error) {
          lastError = error;
          console.warn(`Failed to load ${source}`, error);
        }
      }
      throw lastError || new Error('Excel sources are not available');
    }

    async function loadFromTsvSource() {
      const response = await fetch('books.html', { cache: 'no-store' });
      if (!response.ok) {
        throw new Error('Network error while requesting books.html');
      }
      const text = await response.text();
      const rows = parseTsv(text);
      const books = rows
        .map((row) => normalizeRow(row))
        .filter((book) => book.title || book.author);
      return { books, cachePayload: text, coverUrls: [] };
    }

    function readBooksFromCache() {
      let storage;
      try {
        storage = window.localStorage;
      } catch (error) {
        console.warn('Local storage is not available', error);
        return null;
      }
      if (!storage) {
        return null;
      }
      try {
        const raw = storage.getItem(BOOK_CACHE_KEY);
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        if (parsed.version !== BOOK_CACHE_VERSION) return null;
        if (!Array.isArray(parsed.books) || !parsed.books.length) return null;
        if (typeof parsed.timestamp !== 'number' || Date.now() - parsed.timestamp > BOOK_CACHE_TTL) {
          return null;
        }
        return parsed;
      } catch (error) {
        console.warn('Failed to read cached books', error);
        return null;
      }
    }

    async function persistBooks(books, payload) {
      let storage;
      try {
        storage = window.localStorage;
      } catch (error) {
        console.warn('Local storage is not available', error);
        return;
      }
      if (!storage) {
        return;
      }
      try {
        const checksum = await hashPayload(payload);
        const cacheRecord = {
          version: BOOK_CACHE_VERSION,
          timestamp: Date.now(),
          checksum,
          books: prepareBooksForCache(books)
        };
        storage.setItem(BOOK_CACHE_KEY, JSON.stringify(cacheRecord));
        state.cacheChecksum = checksum;
      } catch (error) {
        console.warn('Failed to persist book cache', error);
      }
    }

    async function hashPayload(payload) {
      if (!window.crypto?.subtle) {
        return '';
      }
      let data;
      if (typeof payload === 'string') {
        data = new TextEncoder().encode(payload);
      } else if (payload instanceof ArrayBuffer) {
        data = new Uint8Array(payload);
      } else if (ArrayBuffer.isView(payload)) {
        data = new Uint8Array(payload.buffer);
      } else {
        return '';
      }
      const digest = await window.crypto.subtle.digest('SHA-256', data);
      return Array.from(new Uint8Array(digest))
        .map((byte) => byte.toString(16).padStart(2, '0'))
        .join('');
    }

    function parseTsv(text) {
      if (typeof text !== 'string') {
        return [];
      }
      const cleaned = text.replace(/^﻿/, '');
      const lines = cleaned.split(/\r?\n/);
      const headerIndex = lines.findIndex((line) => line.trim());
      if (headerIndex === -1) {
        return [];
      }
      const header = lines[headerIndex].split('\t').map((cell) => cell.trim());
      const rows = [];
      for (let i = headerIndex + 1; i < lines.length; i += 1) {
        const line = lines[i];
        if (!line || !line.trim()) {
          continue;
        }
        const cells = line.split('\t');
        const row = {};
        let hasValue = false;
        header.forEach((key, index) => {
          const value = (cells[index] || '').trim();
          if (value) {
            hasValue = true;
          }
          row[key] = value;
        });
        if (hasValue) {
          rows.push(row);
        }
      }
      return rows;
    }

    function convertSheetRowsToObjects(sheet) {
      if (!sheet || !sheet['!ref'] || !XLSX?.utils) {
        return [];
      }
      const range = XLSX.utils.decode_range(sheet['!ref']);
      const columnCount = range.e.c - range.s.c + 1;
      if (columnCount <= 0) {
        return [];
      }
      const headerRowIndex = range.s.r;
      const headerValues = Array.from({ length: columnCount }, (_, columnIndex) => {
        const address = XLSX.utils.encode_cell({ c: range.s.c + columnIndex, r: headerRowIndex });
        const cell = sheet[address];
        return formatSheetCellValue(cell);
      });
      const result = [];
      for (let rowIndex = headerRowIndex + 1; rowIndex <= range.e.r; rowIndex += 1) {
        const record = { __rowNumber: rowIndex + 1 };
        let hasValue = false;
        for (let columnIndex = 0; columnIndex < columnCount; columnIndex += 1) {
          const address = XLSX.utils.encode_cell({ c: range.s.c + columnIndex, r: rowIndex });
          const cell = sheet[address];
          const value = formatSheetCellValue(cell);
          if (value) {
            hasValue = true;
          }
          const header = headerValues[columnIndex];
          if (header) {
            record[header] = value;
          }
          record[`__COL_${getColumnLetter(columnIndex)}`] = value;
        }
        if (hasValue) {
          result.push(record);
        }
      }
      return result;
    }

    function formatSheetCellValue(cell) {
      if (!cell) {
        return '';
      }
      const raw = typeof XLSX?.utils?.format_cell === 'function' ? XLSX.utils.format_cell(cell) : cell.v;
      if (raw === undefined || raw === null) {
        return '';
      }
      if (typeof raw === 'string') {
        return raw.trim();
      }
      return String(raw).trim();
    }

    async function loadWorkbookArchive(buffer) {
      if (typeof JSZip === 'undefined' || !buffer) {
        return null;
      }
      try {
        return await JSZip.loadAsync(buffer);
      } catch (error) {
        console.warn('Unable to open workbook archive', error);
        return null;
      }
    }

    async function resolveWorksheetPath(zip) {
      if (!zip) {
        return DEFAULT_WORKSHEET_PATH;
      }
      try {
        const workbookXml = await readZipText(zip, 'xl/workbook.xml');
        if (!workbookXml) {
          return DEFAULT_WORKSHEET_PATH;
        }
        const parser = new DOMParser();
        const workbookDoc = parser.parseFromString(workbookXml, 'application/xml');
        const sheetNodes = workbookDoc.getElementsByTagName('sheet');
        if (!sheetNodes || !sheetNodes.length) {
          return DEFAULT_WORKSHEET_PATH;
        }
        const firstSheet = sheetNodes[0];
        const relId = firstSheet.getAttributeNS('http://schemas.openxmlformats.org/officeDocument/2006/relationships', 'id');
        if (!relId) {
          return DEFAULT_WORKSHEET_PATH;
        }
        const relsXml = await readZipText(zip, 'xl/_rels/workbook.xml.rels');
        if (!relsXml) {
          return DEFAULT_WORKSHEET_PATH;
        }
        const relsDoc = parser.parseFromString(relsXml, 'application/xml');
        const relationships = relsDoc.getElementsByTagName('Relationship');
        for (let i = 0; i < relationships.length; i += 1) {
          const rel = relationships[i];
          if (rel.getAttribute('Id') === relId) {
            const target = rel.getAttribute('Target');
            if (target) {
              return `xl/${target.replace(/^\.\//, '')}`;
            }
            break;
          }
        }
      } catch (error) {
        console.warn('Failed to resolve worksheet path', error);
      }
      return DEFAULT_WORKSHEET_PATH;
    }

    async function extractEmbeddedCovers(zip, worksheetPath) {
      const emptyResult = { map: new Map(), urls: [] };
      if (!zip || !worksheetPath) {
        return emptyResult;
      }
      try {
        const parser = new DOMParser();
        const worksheetDir = worksheetPath.substring(0, worksheetPath.lastIndexOf('/') + 1);
        const worksheetFile = worksheetPath.substring(worksheetPath.lastIndexOf('/') + 1);
        const worksheetRelsPath = `${worksheetDir}_rels/${worksheetFile}.rels`;
        const worksheetRelsXml = await readZipText(zip, worksheetRelsPath);
        if (!worksheetRelsXml) {
          return emptyResult;
        }
        const worksheetRelsDoc = parser.parseFromString(worksheetRelsXml, 'application/xml');
        const drawingRelationships = Array.from(
          worksheetRelsDoc.getElementsByTagName('Relationship')
        ).filter((node) =>
          node.getAttribute('Type') ===
          'http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing'
        );
        if (!drawingRelationships.length) {
          return emptyResult;
        }
        const coverTargets = new Map();
        for (const drawingRel of drawingRelationships) {
          const drawingTarget = drawingRel.getAttribute('Target');
          if (!drawingTarget) {
            continue;
          }
          const drawingPath = resolveZipPath(worksheetPath, drawingTarget);
          const drawingXml = await readZipText(zip, drawingPath);
          if (!drawingXml) {
            continue;
          }
          const drawingDoc = parser.parseFromString(drawingXml, 'application/xml');
          const drawingDir = drawingPath.substring(0, drawingPath.lastIndexOf('/') + 1);
          const drawingFile = drawingPath.substring(drawingPath.lastIndexOf('/') + 1);
          const drawingRelsPath = `${drawingDir}_rels/${drawingFile}.rels`;
          const drawingRelsXml = await readZipText(zip, drawingRelsPath);
          if (!drawingRelsXml) {
            continue;
          }
          const drawingRelsDoc = parser.parseFromString(drawingRelsXml, 'application/xml');
          const drawingRelMap = new Map();
          Array.from(drawingRelsDoc.getElementsByTagName('Relationship')).forEach((node) => {
            drawingRelMap.set(node.getAttribute('Id'), node.getAttribute('Target'));
          });
          const anchors = [
            ...Array.from(
              drawingDoc.getElementsByTagNameNS(
                'http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing',
                'oneCellAnchor'
              )
            ),
            ...Array.from(
              drawingDoc.getElementsByTagNameNS(
                'http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing',
                'twoCellAnchor'
              )
            )
          ];
          anchors.forEach((anchor) => {
            const fromNode = anchor.getElementsByTagNameNS(
              'http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing',
              'from'
            )[0];
            if (!fromNode) {
              return;
            }
            const colNode = fromNode.getElementsByTagNameNS(
              'http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing',
              'col'
            )[0];
            const rowNode = fromNode.getElementsByTagNameNS(
              'http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing',
              'row'
            )[0];
            if (!colNode || !rowNode) {
              return;
            }
            const columnIndex = Number(colNode.textContent || colNode.innerHTML || 0);
            if (!Number.isFinite(columnIndex) || columnIndex !== COVER_COLUMN_INDEX) {
              return;
            }
            const rowIndex = Number(rowNode.textContent || rowNode.innerHTML || 0);
            if (!Number.isFinite(rowIndex)) {
              return;
            }
            const picNode = anchor.getElementsByTagNameNS(
              'http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing',
              'pic'
            )[0];
            if (!picNode) {
              return;
            }
            const blipNode = picNode.getElementsByTagNameNS(
              'http://schemas.openxmlformats.org/drawingml/2006/main',
              'blip'
            )[0];
            if (!blipNode) {
              return;
            }
            const relId = blipNode.getAttributeNS(
              'http://schemas.openxmlformats.org/officeDocument/2006/relationships',
              'embed'
            );
            if (!relId || !drawingRelMap.has(relId)) {
              return;
            }
            const targetPath = resolveZipPath(drawingPath, drawingRelMap.get(relId));
            coverTargets.set(rowIndex + 1, targetPath);
          });
        }
        if (!coverTargets.size) {
          return emptyResult;
        }
        const coverMap = new Map();
        const blobUrls = [];
        const entries = Array.from(coverTargets.entries());
        await Promise.all(
          entries.map(async ([rowNumber, targetPath]) => {
            const file = zip.file(targetPath);
            if (!file) {
              return;
            }
            try {
              const mimeType = getMimeTypeFromPath(targetPath);
              const arrayBuffer = await file.async('arraybuffer');
              const blob = new Blob([arrayBuffer], { type: mimeType });
              const objectUrl = URL.createObjectURL(blob);
              coverMap.set(rowNumber, objectUrl);
              blobUrls.push(objectUrl);
            } catch (error) {
              console.warn('Unable to decode embedded cover', error);
            }
          })
        );
        return { map: coverMap, urls: blobUrls };
      } catch (error) {
        console.warn('Failed to extract embedded covers', error);
        return emptyResult;
      }
    }

    async function readZipText(zip, path) {
      if (!zip || !path) {
        return '';
      }
      try {
        const file = zip.file(path.replace(/^\/+/, ''));
        if (!file) {
          return '';
        }
        return await file.async('text');
      } catch (error) {
        console.warn('Unable to read zip entry', path, error);
        return '';
      }
    }

    function resolveZipPath(basePath, relativePath) {
      if (!relativePath) {
        return basePath;
      }
      if (/^\//.test(relativePath)) {
        return relativePath.replace(/^\/+/, '');
      }
      const baseParts = basePath.split('/').slice(0, -1);
      const segments = relativePath.split('/');
      segments.forEach((segment) => {
        if (!segment || segment === '.') {
          return;
        }
        if (segment === '..') {
          if (baseParts.length) {
            baseParts.pop();
          }
        } else {
          baseParts.push(segment);
        }
      });
      return baseParts.join('/');
    }

    function getMimeTypeFromPath(path) {
      if (!path) {
        return 'image/png';
      }
      if (/\.jpe?g$/i.test(path)) {
        return 'image/jpeg';
      }
      if (/\.gif$/i.test(path)) {
        return 'image/gif';
      }
      if (/\.webp$/i.test(path)) {
        return 'image/webp';
      }
      if (/\.svg$/i.test(path)) {
        return 'image/svg+xml';
      }
      return 'image/png';
    }

    function getEmbeddedCoverForRow(rowNumber, coverMap) {
      if (!coverMap || !rowNumber) {
        return '';
      }
      return coverMap.get(rowNumber) || coverMap.get(rowNumber + 1) || coverMap.get(rowNumber - 1) || '';
    }

    function cleanupCoverUrls() {
      if (!state.coverUrlRegistry || !state.coverUrlRegistry.length) {
        return;
      }
      revokeObjectUrls(state.coverUrlRegistry);
      state.coverUrlRegistry = [];
    }

    function revokeObjectUrls(urls) {
      if (!Array.isArray(urls) || !urls.length) {
        return;
      }
      urls.forEach((url) => {
        try {
          URL.revokeObjectURL(url);
        } catch (error) {
          console.warn('Unable to revoke object URL', error);
        }
      });
    }

    function prepareBooksForCache(books) {
      if (!Array.isArray(books)) {
        return [];
      }
      return books.map((book) => {
        if (book?.cover && /^blob:/i.test(book.cover)) {
          const fallbackKey = book.title || book.author || book.specialty || 'default';
          return { ...book, cover: getFallbackCover(fallbackKey) };
        }
        return book;
      });
    }

    function getColumnLetter(index) {
      let letter = '';
      let current = Number(index);
      if (!Number.isFinite(current) || current < 0) {
        return '';
      }
      while (current >= 0) {
        letter = String.fromCharCode((current % 26) + 65) + letter;
        current = Math.floor(current / 26) - 1;
      }
      return letter;
    }

    function normalizeRow(row, embeddedCover) {
      const getValue = (keys) => {
        for (const key of keys) {
          if (row[key] !== undefined && row[key] !== null) {
            const value = String(row[key]).trim();
            if (value) {
              return value;
            }
          }
        }
        return '';
      };
      const title = getValue(columnAliases.title);
      const author = getValue(columnAliases.author);
      const specialty = getValue(columnAliases.specialty);
      const { sanitizedLink, hasExternalLink } = normalizeLink(getValue(columnAliases.link), title, author);
      return {
        title,
        author,
        publisher: getValue(columnAliases.publisher),
        city: getValue(columnAliases.city),
        year: getValue(columnAliases.year),
        pages: getValue(columnAliases.pages),
        language: getValue(columnAliases.language),
        specialty,
        link: sanitizedLink,
        hasExternalLink,
        cover: resolveCoverValue(getValue(columnAliases.cover), title, author, specialty, embeddedCover)
      };
    }

    function normalizeLink(value, title, author) {
      const trimmed = (value || '').trim();
      if (trimmed) {
        if (/^https?:\/\//i.test(trimmed)) {
          return { sanitizedLink: trimmed, hasExternalLink: true };
        }
        if (/^www\./i.test(trimmed)) {
          return { sanitizedLink: `https://${trimmed}`, hasExternalLink: true };
        }
      }
      const query = [title, author].filter(Boolean).join(' ').trim();
      const fallbackQuery = query || trimmed;
      const fallbackLink = `https://www.google.com/search?q=${encodeURIComponent(fallbackQuery || 'medical book')}`;
      return { sanitizedLink: fallbackLink, hasExternalLink: false };
    }

    function resolveCoverValue(value, title, author, specialty, embeddedCover) {
      let source = value;
      const fallbackKey = [title, author, specialty].filter(Boolean).join(' | ');
      if (typeof source === 'string') {
        const trimmed = source.trim();
        if (!trimmed) {
          source = '';
        } else if ((trimmed.startsWith('{') || trimmed.startsWith('[')) && trimmed.length > 4) {
          try {
            const parsed = JSON.parse(trimmed);
            if (typeof parsed === 'string') {
              source = parsed;
            } else if (Array.isArray(parsed)) {
              source = parsed.find((item) => typeof item === 'string' && item.trim());
            } else if (parsed && typeof parsed.url === 'string') {
              source = parsed.url;
            }
          } catch (error) {
            console.warn('Unable to parse cover value', error);
          }
        } else {
          source = trimmed;
        }
      }
      if (!source && embeddedCover) {
        source = embeddedCover;
      }
      return sanitizeUrl(source, getFallbackCover(fallbackKey));
    }

    function sanitizeUrl(value, fallback) {
      if (!value || typeof value !== 'string') {
        return fallback;
      }
      const trimmed = value.trim();
      if (!trimmed) {
        return fallback;
      }
      if (/^(?:https?:|data:image|blob:)/i.test(trimmed)) {
        return trimmed;
      }
      if (/^(?:\.\/|\/)?[\w\-./]+\.(?:png|jpe?g|webp|gif|svg)$/i.test(trimmed)) {
        return trimmed.startsWith('./') || trimmed.startsWith('/') ? trimmed : `./${trimmed}`;
      }
      return fallback;
    }

    function getFallbackCover(key) {
      const normalized = (key || 'default').toLowerCase();
      if (fallbackCoverCache.has(normalized)) {
        return fallbackCoverCache.get(normalized);
      }
      const hash = hashString(normalized);
      const index = Math.abs(hash) % fallbackCoverImages.length;
      const url = `./${fallbackCoverImages[index]}`;
      fallbackCoverCache.set(normalized, url);
      return url;
    }

    function hashString(value) {
      let hash = 0;
      const str = value || '';
      for (let i = 0; i < str.length; i += 1) {
        hash = (hash << 5) - hash + str.charCodeAt(i);
        hash |= 0;
      }
      return hash;
    }

    function escapeHtml(value) {
      return String(value || '')
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    function renderBooks() {
      const grid = document.getElementById('book-grid');
      if (!grid) return;
      const dict = translations[state.lang] || translations.ru;
      const books = getFilteredBooks();
      if (!state.books.length) {
        grid.innerHTML = `<div class="empty-state">${dict.statusLoading}</div>`;
        updateStatus('statusLoading');
        return;
      }
      grid.innerHTML = '';
      if (!books.length) {
        grid.innerHTML = `<div class="empty-state">${dict.statusEmpty}</div>`;
      } else {
        const fragment = document.createDocumentFragment();
        books.forEach((book) => {
          fragment.appendChild(createBookCard(book, dict));
        });
        grid.appendChild(fragment);
      }
      updateCountStatus(books.length, state.books.length);
    }

    function getFilteredBooks() {
      return state.books.filter((book) => {
        if (state.filters.title && !(book.title || '').toLowerCase().includes(state.filters.title)) {
          return false;
        }
        if (state.filters.author && !(book.author || '').toLowerCase().includes(state.filters.author)) {
          return false;
        }
        if (state.filters.year && !(book.year || '').toLowerCase().includes(state.filters.year)) {
          return false;
        }
        if (state.filters.specialty && !(book.specialty || '').toLowerCase().includes(state.filters.specialty)) {
          return false;
        }
        if (state.filters.language && !(book.language || '').toLowerCase().includes(state.filters.language)) {
          return false;
        }
        return true;
      });
    }

    function createBookCard(book, dict) {
      const article = document.createElement('article');
      article.className = 'book-card';
      const specialty = book.specialty || dict.cardSpecialtyEmpty;
      const language = book.language || dict.cardLanguageEmpty;
      const targetLink = book.link || `https://www.google.com/search?q=${encodeURIComponent((book.title || '') + ' ' + (book.author || ''))}`;
      const isExternal = book.hasExternalLink === true && Boolean(book.link);
      const safeTitle = escapeHtml(book.title || dict.cardSpecialtyEmpty);
      const safeAuthor = escapeHtml(book.author || '—');
      const safeLanguage = escapeHtml(language);
      const safePublisher = escapeHtml(book.publisher || '—');
      const safeCity = escapeHtml(book.city || '—');
      const safePages = escapeHtml(book.pages || '—');
      const safeYear = escapeHtml(book.year || dict.cardYear);
      const safeSpecialty = escapeHtml(specialty);
      const coverSource = escapeHtml(book.cover || getFallbackCover(book.title || book.author || specialty || 'default'));
      const coverAlt = escapeHtml(book.title || dict.cardCoverAlt);
      article.innerHTML = `
        <div class="book-card__media">
          <img src="${coverSource}" alt="${coverAlt}" loading="lazy" decoding="async">
        </div>
        <div class="book-card__top">
          <span class="book-card__chip">${safeSpecialty}</span>
          <span class="book-card__chip">${safeYear}</span>
        </div>
        <div>
          <h3 class="book-card__title">${safeTitle}</h3>
          <p class="book-card__author">${dict.cardAuthor}: ${safeAuthor}</p>
        </div>
        <div class="book-card__details">
          <div>
            <span class="book-card__label">${dict.cardLanguage}</span>
            <strong>${safeLanguage}</strong>
          </div>
          <div>
            <span class="book-card__label">${dict.cardPublisher}</span>
            <strong>${safePublisher}</strong>
          </div>
          <div>
            <span class="book-card__label">${dict.cardCity}</span>
            <strong>${safeCity}</strong>
          </div>
          <div>
            <span class="book-card__label">${dict.cardPages}</span>
            <strong>${safePages}</strong>
          </div>
        </div>
      `;
      const actions = document.createElement('div');
      actions.className = 'book-card__actions';
      const button = document.createElement('a');
      button.className = 'book-card__link';
      button.textContent = isExternal ? dict.cardOpen : dict.cardSearch;
      button.href = targetLink;
      button.target = '_blank';
      button.rel = 'noopener';
      actions.appendChild(button);
      article.appendChild(actions);
      return article;
    }

    function updateStatus(key) {
      const pill = document.getElementById('status-pill');
      if (!pill) return;
      const dict = translations[state.lang] || translations.ru;
      const template = dict[key];
      pill.textContent = template || '';
    }

    function updateCountStatus(count, total) {
      const pill = document.getElementById('status-pill');
      if (!pill) return;
      const dict = translations[state.lang] || translations.ru;
      const key = count === total ? 'statusTotal' : 'statusFiltered';
      const template = dict[key] || '';
      pill.textContent = template.replace('{count}', count).replace('{total}', total);
    }
  </script>
</body>
</html>
